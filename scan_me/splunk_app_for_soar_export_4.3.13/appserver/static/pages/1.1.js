webpackJsonp([1],{

/***/ 132:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n    var _ = __webpack_require__(121);\n    var Backbone = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"backbone\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    var BaseManager = __webpack_require__(134);\n    var BaseSplunkView = __webpack_require__(135);\n    var BaseTokenModel = __webpack_require__(127);\n    var SearchModels = __webpack_require__(137);\n    var console = window.console;\n\n    var indent = function(count) {\n        var str = '';\n        for (var i = 0; i < count; i++) { \n            str += '    '; \n        }\n        return str;\n    };\n\n    var warn = function(msg) {\n        return (\"WARNING: \" + msg);\n    };\n\n    var categoryEnum = {\n        MANAGER: 'manager',\n        VIEW: 'view',\n        NAMESPACE: 'namespace',\n        UNKNOWN: 'unknown'\n    };\n\n    var Debugger = Backbone.Model.extend(/** @lends splunkjs.mvc.Debugger.prototype */{\n        ready : false,\n\n        initialize: function() { \n            var that = this;    \n\n            that.registry = that.get('registry');\n\n            if (!that.registry) {\n                console.log(\"splunk.mvc debugging interface could not find the registry\");\n                return;\n            }\n\n            // For now this is a command-line tool, so we put information on the command line.\n            console.log(\"The Splunkjs debugger is running. For help, enter 'splunkjs.mvc.Debugger.help()'\");\n        },\n\n        isReady: function() {\n            return this.ready;\n        },\n\n        getDebugData: function() {\n\n            var that = this;\n            var components = [];\n\n            var registeredComponentKeys = that.registry.getInstanceNames();\n\n            _.each(registeredComponentKeys, function(elementID) {\n                var registryElement = that.registry.getInstance(elementID);\n                var type = that._getComponentType(registryElement);\n                var category = that._getComponentCategory(registryElement);\n                var validOptions = [];\n                \n                var elementMetaData = { \n                    'id' : elementID,\n                    'category' : category,\n                    'type': type,\n                    'warnings': []\n                };\n\n                // Add data to views\n                if (category === categoryEnum.VIEW) {\n                    var managerid = null;\n                    var settings = {};\n                    validOptions = that._getValidViewOptions(registryElement);\n\n                    // If the view has settings we inspect them for issues\n                    // JIRA: DVPL-3316\n                    if (registryElement.settings) {\n                        managerid = registryElement.settings.get('managerid') || null;\n                        settings = _.clone(registryElement.settings.attributes);\n                        \n                        _.each(_.keys(settings), function(key) {\n\n                            // If a setting is not known to be valid we add a warning\n                            if (!_.contains(validOptions, key)) {\n\n                                // Ignore unrecognized map and chart settings\n                                // JIRA: DVPL-3317\n                                var partOne = key.split('.')[0];\n                                if (!(partOne === 'mapping' || partOne === 'charting')) {\n                                    elementMetaData.warnings.push(warn(key + \" is not a recognized setting.\"));\n                                }\n                            }\n                        });\n                    }\n                    \n                    elementMetaData.managerid = managerid;\n                    elementMetaData.settings = settings;\n                    elementMetaData.el = registryElement.el || \"no element set\";\n                }\n                // Add data to token namespaces\n                if (category === categoryEnum.NAMESPACE) {\n                    elementMetaData.tokens = [];\n\n                    // For each token in the namespace, attach the value and an empty list of \n                    // listeners that will be populated later \n                    _.each(registryElement.attributes, function(value, key) {\n                        var tokenData = {\n                            name: key,\n                            value : value,\n                            listenerIds: []\n                        };\n                        elementMetaData.tokens.push(tokenData);\n                    });\n                }    \n                // Add data to managers\n                if (category === categoryEnum.MANAGER) {\n                    validOptions = that._getValidManagerOptions(registryElement);\n                    \n                    if (registryElement.attributes) {\n                        var attributes = _.clone(registryElement.attributes);\n                        \n                        _.each(_.keys(attributes), function(key) {\n                            // If a setting is not known to be valid we add a warning\n                            if (!_.contains(validOptions, key)) {\n                                elementMetaData.warnings.push(warn(key + \" is not a recognized attribute\"));\n                            }\n                        });\n                    }\n                    \n                    elementMetaData.attributes = registryElement.attributes;\n                    elementMetaData.query = registryElement.query;\n                    elementMetaData.search = registryElement.search;\n                }\n\n                // Add token data to everything but namespaces\n                if (category !== categoryEnum.NAMESPACE) {\n                    elementMetaData.bindings = that._getComponentBindings(elementID);\n                }\n                components.push(elementMetaData);                \n            });\n                \n            // Now that we have our elements in place, we can check connections between them\n            // and look for other potential issues. First, separate componenet types for convenience.\n            var managers = _.where(components, {'category' : categoryEnum.MANAGER});\n            var views = _.where(components, {'category' : categoryEnum.VIEW});\n            var namespaces = _.where(components, {'category' : categoryEnum.NAMESPACE});\n            \n            // Enumerate views bound to each manager and check for issues\n            _.each(managers, function(manager) {\n                // Pluck the view ids from views where managerid is this manager's id\n                manager.viewIds = _.pluck(_.where(views, {'managerid': manager.id}), 'id');\n\n                // If there are no views bound to the search, push a warning\n                if (manager.viewIds.length < 1) { \n                    manager.warnings.push(warn(\"no views bound to search manager.\"));\n                }\n            });\n\n            // Check for views bound to non-existent managers\n            _.each(views, function(view) {\n                if (view.managerid) {\n                    if (!_.contains(_.pluck(managers, 'id'), view.managerid)) {\n                        view.warnings.push(warn(view.managerid + \" is not a registered manager.\"));\n                    }\n                }\n            });\n\n            // Find components bound to each token and attach them to token metadata\n            _.each(namespaces, function(namespace) {\n                _.each(namespace.tokens, function(token) {\n                    // Look through views and managers and find those that watch this\n                    // token's name\n                    var listeners = _.filter(_.union(managers, views), function(item) {\n                        return _.some(item.bindings, function(binding) {\n                            if (binding && binding.observes && binding.observes.length > 0) {\n                                return _.some(binding.observes, function(observes) {\n                                    return (observes.namespace === namespace.id && observes.name === token.name);        \n                                });\n                            }\n                        });\n                    });\n\n                    // Attach just the ids of the listeners\n                    token.listenerIds = _.pluck(listeners, 'id');\n                });\n            });\n\n            return components;\n        },\n\n        _getValidViewOptions: function(element) {\n            var options = ['id', 'name', 'managerid', 'manager', 'app', 'el', 'data'];\n\n            // Again we check this is valid.\n            if (element.constructor.prototype.options) {\n                options = _.union(options, _.keys(element.constructor.prototype.options));\n            }\n            return options;\n        },\n\n        _getValidManagerOptions: function(element) {\n            var validOptions = _.union(\n                ['app', 'id', 'owner', 'name', 'data'], \n                _.keys(element.constructor.prototype.defaults) || [], \n                SearchModels.SearchSettingsModel.ALLOWED_ATTRIBUTES\n            );\n            \n            return validOptions;\n        },\n\n        _getComponentType: function(component) {\n            var type = \"Unknown type\";\n            if (component.moduleId) {\n                var name = component.moduleId.split('/').pop();\n                if (name.length > 0) {\n                    type = name;\n                }                \n            }\n            return type;\n        },\n\n        _getComponentCategory: function(component) {\n            var category = categoryEnum.UNKNOWN;\n\n            if (component instanceof BaseSplunkView) {\n                category = categoryEnum.VIEW;\n            }\n            else if (component instanceof BaseManager) {\n                category = categoryEnum.MANAGER;\n            }\n            else if (component instanceof BaseTokenModel) {\n                category = categoryEnum.NAMESPACE;\n            }\n            return category;\n        },\n\n        _getComponentTokenBoundProperties: function(componentId) {\n            var tokenBoundProperties = [];\n            var bindings = this._getComponentBindings(componentId);\n            tokenBoundProperties = _.keys(bindings);\n            return tokenBoundProperties;\n        },\n\n        _getComponentBindings: function(componentId) {\n            var component = this.registry.getInstance(componentId);\n            \n            var bindings = {};\n            if (component && component.settings) {\n                bindings = _.extend(bindings, _.clone(component.settings._bindings));\n            }\n            return bindings;\n        },\n        \n        createError: function(message) {            \n            return message;\n        },\n\n        printViewInfo: function() {\n            var that = this;\n            var views = that.getInfoForViews();\n\n            console.log(\"Views:\");\n            _.each(views, function(view) {\n                console.log(indent(1) + \"ID: \" + view.id);\n                console.log(indent(2) + \"Type: \" + view.type);\n                console.log(indent(2) + \"Manager: \" + view.managerid);\n                console.log(indent(2) + \"Element: \", view.el);\n                console.log(indent(2) + \"Settings: \");\n                _.each(_.keys(view.settings), function(key) {\n                    var tokenInfo = \"\";\n                    var binding = view.bindings[key];\n                    var hasTokens = binding && binding.observes && binding.observes.length > 0;\n                    if (hasTokens) {\n                        var template = JSON.stringify(binding.template);\n                        var partiallyResolvedValue = JSON.stringify(binding.computeValue(/*_retainUnmatchedTokens=*/true));\n                        tokenInfo = \" [bound: \" + template + \", resolved: \" + partiallyResolvedValue + \"]\";    \n                    }\n                    console.log(indent(3) + key + \": \" + JSON.stringify(view.settings[key]) + tokenInfo); \n                });\n                if(view.warnings.length>0) {\n                    console.log(indent(2) + \"WARNINGS: \");\n                    _.each(view.warnings, function(warning) {\n                        console.log(indent(3) + warning);\n                    });\n                }\n            });\n        },\n\n        printSearchManagerInfo: function() {\n            var that = this;\n            var managers = that.getInfoForManagers();\n\n            console.log(\"Search Managers:\");\n            _.each(managers, function(manager) {\n                console.log(indent(1) + \"ID: \" + manager.id);\n                console.log(indent(2) + \"Type: \" + manager.type);\n                if (manager.attributes) {\n                    console.log(indent(2) + \"Attributes: \" );\n                    var propertiesToSkip = SearchModels.SearchSettingsModel.ALLOWED_ATTRIBUTES;\n                    \n                    _.each(manager.attributes, function(value, key) {\n                        if (_.contains(propertiesToSkip, key)) {\n                            return;\n                        }\n                        console.log(indent(3) + key + \": \" + JSON.stringify(value)); \n                    });\n                }\n                if (manager.settings && manager.settings.attributes) {\n                    console.log(indent(2) + \"Search Properties: \" );\n                    _.each(manager.settings.attributes, function(value, key) {\n                        var tokenInfo = \"\";\n                        var binding = manager.bindings[key];\n                        var hasTokens = binding && binding.observes && binding.observes.length > 0;\n                        if (hasTokens) {\n                            var template = JSON.stringify(binding.template);\n                            var partiallyResolvedValue = JSON.stringify(binding.computeValue(/*_retainUnmatchedTokens=*/true));\n                            tokenInfo = \" [bound: \" + template + \", resolved: \" + partiallyResolvedValue + \"]\";    \n                        }\n                        console.log(indent(3) + key + \": \" + JSON.stringify(value) + tokenInfo); \n                    });\n                }\n                console.log(indent(2) + \"Views bound to manager: \");\n                _.each(manager.viewIds, function(id) {\n                    console.log(indent(3) + id);\n                });\n                if (manager.warnings.length > 0) {\n                    console.log(indent(2) + \"WARNINGS: \");\n                    _.each(manager.warnings, function(warning) {\n                        console.log(indent(3) + warning);\n                    });\n                }\n            });\n        },\n\n        printTokenNamespaceInfo: function() {\n            var that = this;\n            var namespaces = that.getInfoForNamespaces();\n\n            console.log(\"Token Namespaces:\");\n            _.each(namespaces, function(namespace) {\n                console.log(indent(1) + \"ID: \" + namespace.id);\n                console.log(indent(2) + \"Type: \" + namespace.type);\n                console.log(indent(2) + \"Tokens: \");\n                _.each(namespace.tokens, function(token) {\n                    console.log(indent(3) + token.name + \": \");\n                    console.log(indent(4) + \"value: \" + JSON.stringify(token.value));\n                    console.log(indent(4) + \"listeners: \" + token.listenerIds.join(', '));\n                });\n            });\n        },\n\n        /**\n         * Prints all component info\n         */\n        printComponentInfo: function() {\n            this.printViewInfo();\n            this.printSearchManagerInfo();\n            this.printTokenNamespaceInfo();\n        },\n\n        printWarnings: function() {\n            var that = this;\n            var components = that.getDebugData();\n            console.log(\"WARNINGS:\");\n            _.each(components, function(item) {\n                if (item.warnings.length > 0 ) {\n                    console.log(indent(1), \"ID: \" + item.id + \": \");\n                    _.each(item.warnings, function(warning) {\n                        console.log(indent(2) + warning);\n                    });\n                }             \n            });\n        },\n\n        _getInfoForComponents: function(ctype) {\n            var components = this.getDebugData();\n            if (ctype !== undefined) {\n                return _.where(components, {'category': categoryEnum[ctype]});\n            }\n            return components;\n        },\n\n        getInfoForViews: function() { \n            return this._getInfoForComponents('VIEW'); \n        },\n\n        getInfoForManagers: function() { \n            return this._getInfoForComponents('MANAGER'); \n        },\n\n        getInfoForNamespaces: function() { \n            return this._getInfoForComponents('NAMESPACE'); \n        },\n\n        help : function() { \n            console.log(\"Splunkjs Debugger Commands\");\n            console.log(indent(1) + \"- printWarnings(): Prints all warnings to the console.\");\n            console.log(indent(1) + \"- printComponentInfo(): Prints all debug info and warnings to the console by component.\");\n            console.log(indent(1) + \"- printViewInfo(): Prints debug info for all Splunk views.\");\n            console.log(indent(1) + \"- printSearchManagerInfo(): Prints debug info for all Splunk search managers.\");\n            console.log(indent(1) + \"- printTokenNamespaceInfo(): Prints debug info for Splunk token namespaces.\");\n            console.log(indent(1) + \"- getDebugData(): Returns all debug metadata for components and namespaces.\");\n            console.log(indent(1) + \"- getInfoForViews(): Returns debug metadata for all Splunk views.\");\n            console.log(indent(1) + \"- getInfoForManagers(): Returns debug metadata for all Splunk managers.\");\n            console.log(indent(1) + \"- getInfoForNamespaces(): Returns debug metadata for all Splunk token namespaces.\");\n        }\n\n    });\n    \n    return Debugger;\n}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2Fsb21vdGFuL0RvY3VtZW50cy92bXNoYXJlL3NjcmF0Y2hwYWQvcmVhY3Qvb25zcGx1bmsvbm9kZV9tb2R1bGVzL0BzcGx1bmsvc3BsdW5rLXdlYi1jb3JlL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zcGx1bmtqcy9tdmMvZGVidWdnZXIuanM/OWQ0OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxxRUFBTztBQUNQLFlBQVksbUJBQU8sQ0FBQyxHQUFZO0FBQ2hDLG1CQUFtQixtQkFBTyxDQUFDLG9JQUFVO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLEdBQWU7QUFDN0MseUJBQXlCLG1CQUFPLENBQUMsR0FBa0I7QUFDbkQseUJBQXlCLG1CQUFPLENBQUMsR0FBa0I7QUFDbkQsdUJBQXVCLG1CQUFPLENBQUMsR0FBZTtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVcsTztBQUNsQywwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0M7QUFDQSw0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRDtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGdEQUFnRCxrQ0FBa0M7QUFDbEYsNkNBQTZDLCtCQUErQjtBQUM1RSxrREFBa0Qsb0NBQW9DOztBQUV0RjtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsd0JBQXdCOztBQUVsRjtBQUNBLGlEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhOztBQUViO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUI7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULHdDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkc7QUFDQTtBQUNBLHlHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0Y7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRztBQUNBO0FBQ0EsZ0c7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUI7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0NBQWdDO0FBQzVFO0FBQ0E7QUFDQSxTQUFTOztBQUVULHFDO0FBQ0Esc0Q7QUFDQSxTQUFTOztBQUVULHdDO0FBQ0EseUQ7QUFDQSxTQUFTOztBQUVULDBDO0FBQ0EsMkQ7QUFDQSxTQUFTOztBQUVULDJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQztBQUFBLG9HQUFDIiwiZmlsZSI6IjEzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuICAgIHZhciBCYWNrYm9uZSA9IHJlcXVpcmUoXCJiYWNrYm9uZVwiKTtcbiAgICB2YXIgQmFzZU1hbmFnZXIgPSByZXF1aXJlKCcuL2Jhc2VtYW5hZ2VyJyk7XG4gICAgdmFyIEJhc2VTcGx1bmtWaWV3ID0gcmVxdWlyZSgnLi9iYXNlc3BsdW5rdmlldycpO1xuICAgIHZhciBCYXNlVG9rZW5Nb2RlbCA9IHJlcXVpcmUoJy4vYmFzZXRva2VubW9kZWwnKTtcbiAgICB2YXIgU2VhcmNoTW9kZWxzID0gcmVxdWlyZSgnLi9zZWFyY2htb2RlbCcpO1xuICAgIHZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XG5cbiAgICB2YXIgaW5kZW50ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHsgXG4gICAgICAgICAgICBzdHIgKz0gJyAgICAnOyBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbiAgICB2YXIgd2FybiA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgICByZXR1cm4gKFwiV0FSTklORzogXCIgKyBtc2cpO1xuICAgIH07XG5cbiAgICB2YXIgY2F0ZWdvcnlFbnVtID0ge1xuICAgICAgICBNQU5BR0VSOiAnbWFuYWdlcicsXG4gICAgICAgIFZJRVc6ICd2aWV3JyxcbiAgICAgICAgTkFNRVNQQUNFOiAnbmFtZXNwYWNlJyxcbiAgICAgICAgVU5LTk9XTjogJ3Vua25vd24nXG4gICAgfTtcblxuICAgIHZhciBEZWJ1Z2dlciA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCgvKiogQGxlbmRzIHNwbHVua2pzLm12Yy5EZWJ1Z2dlci5wcm90b3R5cGUgKi97XG4gICAgICAgIHJlYWR5IDogZmFsc2UsXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzOyAgICBcblxuICAgICAgICAgICAgdGhhdC5yZWdpc3RyeSA9IHRoYXQuZ2V0KCdyZWdpc3RyeScpO1xuXG4gICAgICAgICAgICBpZiAoIXRoYXQucmVnaXN0cnkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNwbHVuay5tdmMgZGVidWdnaW5nIGludGVyZmFjZSBjb3VsZCBub3QgZmluZCB0aGUgcmVnaXN0cnlcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3Igbm93IHRoaXMgaXMgYSBjb21tYW5kLWxpbmUgdG9vbCwgc28gd2UgcHV0IGluZm9ybWF0aW9uIG9uIHRoZSBjb21tYW5kIGxpbmUuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRoZSBTcGx1bmtqcyBkZWJ1Z2dlciBpcyBydW5uaW5nLiBGb3IgaGVscCwgZW50ZXIgJ3NwbHVua2pzLm12Yy5EZWJ1Z2dlci5oZWxwKCknXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzUmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGVidWdEYXRhOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcblxuICAgICAgICAgICAgdmFyIHJlZ2lzdGVyZWRDb21wb25lbnRLZXlzID0gdGhhdC5yZWdpc3RyeS5nZXRJbnN0YW5jZU5hbWVzKCk7XG5cbiAgICAgICAgICAgIF8uZWFjaChyZWdpc3RlcmVkQ29tcG9uZW50S2V5cywgZnVuY3Rpb24oZWxlbWVudElEKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZ2lzdHJ5RWxlbWVudCA9IHRoYXQucmVnaXN0cnkuZ2V0SW5zdGFuY2UoZWxlbWVudElEKTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoYXQuX2dldENvbXBvbmVudFR5cGUocmVnaXN0cnlFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcnkgPSB0aGF0Ll9nZXRDb21wb25lbnRDYXRlZ29yeShyZWdpc3RyeUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciB2YWxpZE9wdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudE1ldGFEYXRhID0geyBcbiAgICAgICAgICAgICAgICAgICAgJ2lkJyA6IGVsZW1lbnRJRCxcbiAgICAgICAgICAgICAgICAgICAgJ2NhdGVnb3J5JyA6IGNhdGVnb3J5LFxuICAgICAgICAgICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICd3YXJuaW5ncyc6IFtdXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBkYXRhIHRvIHZpZXdzXG4gICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5ID09PSBjYXRlZ29yeUVudW0uVklFVykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFuYWdlcmlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzID0ge307XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkT3B0aW9ucyA9IHRoYXQuX2dldFZhbGlkVmlld09wdGlvbnMocmVnaXN0cnlFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdmlldyBoYXMgc2V0dGluZ3Mgd2UgaW5zcGVjdCB0aGVtIGZvciBpc3N1ZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gSklSQTogRFZQTC0zMzE2XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyeUVsZW1lbnQuc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXJpZCA9IHJlZ2lzdHJ5RWxlbWVudC5zZXR0aW5ncy5nZXQoJ21hbmFnZXJpZCcpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncyA9IF8uY2xvbmUocmVnaXN0cnlFbGVtZW50LnNldHRpbmdzLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goXy5rZXlzKHNldHRpbmdzKSwgZnVuY3Rpb24oa2V5KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHNldHRpbmcgaXMgbm90IGtub3duIHRvIGJlIHZhbGlkIHdlIGFkZCBhIHdhcm5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV8uY29udGFpbnModmFsaWRPcHRpb25zLCBrZXkpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHVucmVjb2duaXplZCBtYXAgYW5kIGNoYXJ0IHNldHRpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpJUkE6IERWUEwtMzMxN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydE9uZSA9IGtleS5zcGxpdCgnLicpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXJ0T25lID09PSAnbWFwcGluZycgfHwgcGFydE9uZSA9PT0gJ2NoYXJ0aW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRNZXRhRGF0YS53YXJuaW5ncy5wdXNoKHdhcm4oa2V5ICsgXCIgaXMgbm90IGEgcmVjb2duaXplZCBzZXR0aW5nLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1ldGFEYXRhLm1hbmFnZXJpZCA9IG1hbmFnZXJpZDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1ldGFEYXRhLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRNZXRhRGF0YS5lbCA9IHJlZ2lzdHJ5RWxlbWVudC5lbCB8fCBcIm5vIGVsZW1lbnQgc2V0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCBkYXRhIHRvIHRva2VuIG5hbWVzcGFjZXNcbiAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09IGNhdGVnb3J5RW51bS5OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1ldGFEYXRhLnRva2VucyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIHRva2VuIGluIHRoZSBuYW1lc3BhY2UsIGF0dGFjaCB0aGUgdmFsdWUgYW5kIGFuIGVtcHR5IGxpc3Qgb2YgXG4gICAgICAgICAgICAgICAgICAgIC8vIGxpc3RlbmVycyB0aGF0IHdpbGwgYmUgcG9wdWxhdGVkIGxhdGVyIFxuICAgICAgICAgICAgICAgICAgICBfLmVhY2gocmVnaXN0cnlFbGVtZW50LmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbkRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJJZHM6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1ldGFEYXRhLnRva2Vucy5wdXNoKHRva2VuRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICAgICAgLy8gQWRkIGRhdGEgdG8gbWFuYWdlcnNcbiAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcnkgPT09IGNhdGVnb3J5RW51bS5NQU5BR0VSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkT3B0aW9ucyA9IHRoYXQuX2dldFZhbGlkTWFuYWdlck9wdGlvbnMocmVnaXN0cnlFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyeUVsZW1lbnQuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBfLmNsb25lKHJlZ2lzdHJ5RWxlbWVudC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKF8ua2V5cyhhdHRyaWJ1dGVzKSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBzZXR0aW5nIGlzIG5vdCBrbm93biB0byBiZSB2YWxpZCB3ZSBhZGQgYSB3YXJuaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmNvbnRhaW5zKHZhbGlkT3B0aW9ucywga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50TWV0YURhdGEud2FybmluZ3MucHVzaCh3YXJuKGtleSArIFwiIGlzIG5vdCBhIHJlY29nbml6ZWQgYXR0cmlidXRlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1ldGFEYXRhLmF0dHJpYnV0ZXMgPSByZWdpc3RyeUVsZW1lbnQuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1ldGFEYXRhLnF1ZXJ5ID0gcmVnaXN0cnlFbGVtZW50LnF1ZXJ5O1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50TWV0YURhdGEuc2VhcmNoID0gcmVnaXN0cnlFbGVtZW50LnNlYXJjaDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG9rZW4gZGF0YSB0byBldmVyeXRoaW5nIGJ1dCBuYW1lc3BhY2VzXG4gICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5ICE9PSBjYXRlZ29yeUVudW0uTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRNZXRhRGF0YS5iaW5kaW5ncyA9IHRoYXQuX2dldENvbXBvbmVudEJpbmRpbmdzKGVsZW1lbnRJRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChlbGVtZW50TWV0YURhdGEpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTm93IHRoYXQgd2UgaGF2ZSBvdXIgZWxlbWVudHMgaW4gcGxhY2UsIHdlIGNhbiBjaGVjayBjb25uZWN0aW9ucyBiZXR3ZWVuIHRoZW1cbiAgICAgICAgICAgIC8vIGFuZCBsb29rIGZvciBvdGhlciBwb3RlbnRpYWwgaXNzdWVzLiBGaXJzdCwgc2VwYXJhdGUgY29tcG9uZW5ldCB0eXBlcyBmb3IgY29udmVuaWVuY2UuXG4gICAgICAgICAgICB2YXIgbWFuYWdlcnMgPSBfLndoZXJlKGNvbXBvbmVudHMsIHsnY2F0ZWdvcnknIDogY2F0ZWdvcnlFbnVtLk1BTkFHRVJ9KTtcbiAgICAgICAgICAgIHZhciB2aWV3cyA9IF8ud2hlcmUoY29tcG9uZW50cywgeydjYXRlZ29yeScgOiBjYXRlZ29yeUVudW0uVklFV30pO1xuICAgICAgICAgICAgdmFyIG5hbWVzcGFjZXMgPSBfLndoZXJlKGNvbXBvbmVudHMsIHsnY2F0ZWdvcnknIDogY2F0ZWdvcnlFbnVtLk5BTUVTUEFDRX0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBFbnVtZXJhdGUgdmlld3MgYm91bmQgdG8gZWFjaCBtYW5hZ2VyIGFuZCBjaGVjayBmb3IgaXNzdWVzXG4gICAgICAgICAgICBfLmVhY2gobWFuYWdlcnMsIGZ1bmN0aW9uKG1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBQbHVjayB0aGUgdmlldyBpZHMgZnJvbSB2aWV3cyB3aGVyZSBtYW5hZ2VyaWQgaXMgdGhpcyBtYW5hZ2VyJ3MgaWRcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLnZpZXdJZHMgPSBfLnBsdWNrKF8ud2hlcmUodmlld3MsIHsnbWFuYWdlcmlkJzogbWFuYWdlci5pZH0pLCAnaWQnKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyB2aWV3cyBib3VuZCB0byB0aGUgc2VhcmNoLCBwdXNoIGEgd2FybmluZ1xuICAgICAgICAgICAgICAgIGlmIChtYW5hZ2VyLnZpZXdJZHMubGVuZ3RoIDwgMSkgeyBcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci53YXJuaW5ncy5wdXNoKHdhcm4oXCJubyB2aWV3cyBib3VuZCB0byBzZWFyY2ggbWFuYWdlci5cIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3Igdmlld3MgYm91bmQgdG8gbm9uLWV4aXN0ZW50IG1hbmFnZXJzXG4gICAgICAgICAgICBfLmVhY2godmlld3MsIGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlldy5tYW5hZ2VyaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmNvbnRhaW5zKF8ucGx1Y2sobWFuYWdlcnMsICdpZCcpLCB2aWV3Lm1hbmFnZXJpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcud2FybmluZ3MucHVzaCh3YXJuKHZpZXcubWFuYWdlcmlkICsgXCIgaXMgbm90IGEgcmVnaXN0ZXJlZCBtYW5hZ2VyLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRmluZCBjb21wb25lbnRzIGJvdW5kIHRvIGVhY2ggdG9rZW4gYW5kIGF0dGFjaCB0aGVtIHRvIHRva2VuIG1ldGFkYXRhXG4gICAgICAgICAgICBfLmVhY2gobmFtZXNwYWNlcywgZnVuY3Rpb24obmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKG5hbWVzcGFjZS50b2tlbnMsIGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2sgdGhyb3VnaCB2aWV3cyBhbmQgbWFuYWdlcnMgYW5kIGZpbmQgdGhvc2UgdGhhdCB3YXRjaCB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRva2VuJ3MgbmFtZVxuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gXy5maWx0ZXIoXy51bmlvbihtYW5hZ2Vycywgdmlld3MpLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5zb21lKGl0ZW0uYmluZGluZ3MsIGZ1bmN0aW9uKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZyAmJiBiaW5kaW5nLm9ic2VydmVzICYmIGJpbmRpbmcub2JzZXJ2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXy5zb21lKGJpbmRpbmcub2JzZXJ2ZXMsIGZ1bmN0aW9uKG9ic2VydmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG9ic2VydmVzLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlLmlkICYmIG9ic2VydmVzLm5hbWUgPT09IHRva2VuLm5hbWUpOyAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRhY2gganVzdCB0aGUgaWRzIG9mIHRoZSBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ubGlzdGVuZXJJZHMgPSBfLnBsdWNrKGxpc3RlbmVycywgJ2lkJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFZhbGlkVmlld09wdGlvbnM6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gWydpZCcsICduYW1lJywgJ21hbmFnZXJpZCcsICdtYW5hZ2VyJywgJ2FwcCcsICdlbCcsICdkYXRhJ107XG5cbiAgICAgICAgICAgIC8vIEFnYWluIHdlIGNoZWNrIHRoaXMgaXMgdmFsaWQuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfLnVuaW9uKG9wdGlvbnMsIF8ua2V5cyhlbGVtZW50LmNvbnN0cnVjdG9yLnByb3RvdHlwZS5vcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0VmFsaWRNYW5hZ2VyT3B0aW9uczogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHZhbGlkT3B0aW9ucyA9IF8udW5pb24oXG4gICAgICAgICAgICAgICAgWydhcHAnLCAnaWQnLCAnb3duZXInLCAnbmFtZScsICdkYXRhJ10sIFxuICAgICAgICAgICAgICAgIF8ua2V5cyhlbGVtZW50LmNvbnN0cnVjdG9yLnByb3RvdHlwZS5kZWZhdWx0cykgfHwgW10sIFxuICAgICAgICAgICAgICAgIFNlYXJjaE1vZGVscy5TZWFyY2hTZXR0aW5nc01vZGVsLkFMTE9XRURfQVRUUklCVVRFU1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkT3B0aW9ucztcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0Q29tcG9uZW50VHlwZTogZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IFwiVW5rbm93biB0eXBlXCI7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Lm1vZHVsZUlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBjb21wb25lbnQubW9kdWxlSWQuc3BsaXQoJy8nKS5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0Q29tcG9uZW50Q2F0ZWdvcnk6IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGNhdGVnb3J5ID0gY2F0ZWdvcnlFbnVtLlVOS05PV047XG5cbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBCYXNlU3BsdW5rVmlldykge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5ID0gY2F0ZWdvcnlFbnVtLlZJRVc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBCYXNlTWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5ID0gY2F0ZWdvcnlFbnVtLk1BTkFHRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBCYXNlVG9rZW5Nb2RlbCkge1xuICAgICAgICAgICAgICAgIGNhdGVnb3J5ID0gY2F0ZWdvcnlFbnVtLk5BTUVTUEFDRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYXRlZ29yeTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0Q29tcG9uZW50VG9rZW5Cb3VuZFByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5Cb3VuZFByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBiaW5kaW5ncyA9IHRoaXMuX2dldENvbXBvbmVudEJpbmRpbmdzKGNvbXBvbmVudElkKTtcbiAgICAgICAgICAgIHRva2VuQm91bmRQcm9wZXJ0aWVzID0gXy5rZXlzKGJpbmRpbmdzKTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbkJvdW5kUHJvcGVydGllcztcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0Q29tcG9uZW50QmluZGluZ3M6IGZ1bmN0aW9uKGNvbXBvbmVudElkKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWdpc3RyeS5nZXRJbnN0YW5jZShjb21wb25lbnRJZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBiaW5kaW5ncyA9IHt9O1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQuc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5ncyA9IF8uZXh0ZW5kKGJpbmRpbmdzLCBfLmNsb25lKGNvbXBvbmVudC5zZXR0aW5ncy5fYmluZGluZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5ncztcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGNyZWF0ZUVycm9yOiBmdW5jdGlvbihtZXNzYWdlKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcmludFZpZXdJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciB2aWV3cyA9IHRoYXQuZ2V0SW5mb0ZvclZpZXdzKCk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVmlld3M6XCIpO1xuICAgICAgICAgICAgXy5lYWNoKHZpZXdzLCBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZW50KDEpICsgXCJJRDogXCIgKyB2aWV3LmlkKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbmRlbnQoMikgKyBcIlR5cGU6IFwiICsgdmlldy50eXBlKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbmRlbnQoMikgKyBcIk1hbmFnZXI6IFwiICsgdmlldy5tYW5hZ2VyaWQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgyKSArIFwiRWxlbWVudDogXCIsIHZpZXcuZWwpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgyKSArIFwiU2V0dGluZ3M6IFwiKTtcbiAgICAgICAgICAgICAgICBfLmVhY2goXy5rZXlzKHZpZXcuc2V0dGluZ3MpLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuSW5mbyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nID0gdmlldy5iaW5kaW5nc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzVG9rZW5zID0gYmluZGluZyAmJiBiaW5kaW5nLm9ic2VydmVzICYmIGJpbmRpbmcub2JzZXJ2ZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Rva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gSlNPTi5zdHJpbmdpZnkoYmluZGluZy50ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbGx5UmVzb2x2ZWRWYWx1ZSA9IEpTT04uc3RyaW5naWZ5KGJpbmRpbmcuY29tcHV0ZVZhbHVlKC8qX3JldGFpblVubWF0Y2hlZFRva2Vucz0qL3RydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuSW5mbyA9IFwiIFtib3VuZDogXCIgKyB0ZW1wbGF0ZSArIFwiLCByZXNvbHZlZDogXCIgKyBwYXJ0aWFsbHlSZXNvbHZlZFZhbHVlICsgXCJdXCI7ICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgzKSArIGtleSArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KHZpZXcuc2V0dGluZ3Nba2V5XSkgKyB0b2tlbkluZm8pOyBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZih2aWV3Lndhcm5pbmdzLmxlbmd0aD4wKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgyKSArIFwiV0FSTklOR1M6IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHZpZXcud2FybmluZ3MsIGZ1bmN0aW9uKHdhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgzKSArIHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcmludFNlYXJjaE1hbmFnZXJJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBtYW5hZ2VycyA9IHRoYXQuZ2V0SW5mb0Zvck1hbmFnZXJzKCk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2VhcmNoIE1hbmFnZXJzOlwiKTtcbiAgICAgICAgICAgIF8uZWFjaChtYW5hZ2VycywgZnVuY3Rpb24obWFuYWdlcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgxKSArIFwiSUQ6IFwiICsgbWFuYWdlci5pZCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZW50KDIpICsgXCJUeXBlOiBcIiArIG1hbmFnZXIudHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hbmFnZXIuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbmRlbnQoMikgKyBcIkF0dHJpYnV0ZXM6IFwiICk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzVG9Ta2lwID0gU2VhcmNoTW9kZWxzLlNlYXJjaFNldHRpbmdzTW9kZWwuQUxMT1dFRF9BVFRSSUJVVEVTO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKG1hbmFnZXIuYXR0cmlidXRlcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8uY29udGFpbnMocHJvcGVydGllc1RvU2tpcCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgzKSArIGtleSArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7IFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hbmFnZXIuc2V0dGluZ3MgJiYgbWFuYWdlci5zZXR0aW5ncy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgyKSArIFwiU2VhcmNoIFByb3BlcnRpZXM6IFwiICk7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChtYW5hZ2VyLnNldHRpbmdzLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbkluZm8gPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSBtYW5hZ2VyLmJpbmRpbmdzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzVG9rZW5zID0gYmluZGluZyAmJiBiaW5kaW5nLm9ic2VydmVzICYmIGJpbmRpbmcub2JzZXJ2ZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSBKU09OLnN0cmluZ2lmeShiaW5kaW5nLnRlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydGlhbGx5UmVzb2x2ZWRWYWx1ZSA9IEpTT04uc3RyaW5naWZ5KGJpbmRpbmcuY29tcHV0ZVZhbHVlKC8qX3JldGFpblVubWF0Y2hlZFRva2Vucz0qL3RydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkluZm8gPSBcIiBbYm91bmQ6IFwiICsgdGVtcGxhdGUgKyBcIiwgcmVzb2x2ZWQ6IFwiICsgcGFydGlhbGx5UmVzb2x2ZWRWYWx1ZSArIFwiXVwiOyAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgzKSArIGtleSArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArIHRva2VuSW5mbyk7IFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZW50KDIpICsgXCJWaWV3cyBib3VuZCB0byBtYW5hZ2VyOiBcIik7XG4gICAgICAgICAgICAgICAgXy5lYWNoKG1hbmFnZXIudmlld0lkcywgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZW50KDMpICsgaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChtYW5hZ2VyLndhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZW50KDIpICsgXCJXQVJOSU5HUzogXCIpO1xuICAgICAgICAgICAgICAgICAgICBfLmVhY2gobWFuYWdlci53YXJuaW5ncywgZnVuY3Rpb24od2FybmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZW50KDMpICsgd2FybmluZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHByaW50VG9rZW5OYW1lc3BhY2VJbmZvOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2VzID0gdGhhdC5nZXRJbmZvRm9yTmFtZXNwYWNlcygpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlRva2VuIE5hbWVzcGFjZXM6XCIpO1xuICAgICAgICAgICAgXy5lYWNoKG5hbWVzcGFjZXMsIGZ1bmN0aW9uKG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgxKSArIFwiSUQ6IFwiICsgbmFtZXNwYWNlLmlkKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbmRlbnQoMikgKyBcIlR5cGU6IFwiICsgbmFtZXNwYWNlLnR5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgyKSArIFwiVG9rZW5zOiBcIik7XG4gICAgICAgICAgICAgICAgXy5lYWNoKG5hbWVzcGFjZS50b2tlbnMsIGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgzKSArIHRva2VuLm5hbWUgKyBcIjogXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpbmRlbnQoNCkgKyBcInZhbHVlOiBcIiArIEpTT04uc3RyaW5naWZ5KHRva2VuLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCg0KSArIFwibGlzdGVuZXJzOiBcIiArIHRva2VuLmxpc3RlbmVySWRzLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaW50cyBhbGwgY29tcG9uZW50IGluZm9cbiAgICAgICAgICovXG4gICAgICAgIHByaW50Q29tcG9uZW50SW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnByaW50Vmlld0luZm8oKTtcbiAgICAgICAgICAgIHRoaXMucHJpbnRTZWFyY2hNYW5hZ2VySW5mbygpO1xuICAgICAgICAgICAgdGhpcy5wcmludFRva2VuTmFtZXNwYWNlSW5mbygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHByaW50V2FybmluZ3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSB0aGF0LmdldERlYnVnRGF0YSgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJXQVJOSU5HUzpcIik7XG4gICAgICAgICAgICBfLmVhY2goY29tcG9uZW50cywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLndhcm5pbmdzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgxKSwgXCJJRDogXCIgKyBpdGVtLmlkICsgXCI6IFwiKTtcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGl0ZW0ud2FybmluZ3MsIGZ1bmN0aW9uKHdhcm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgyKSArIHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEluZm9Gb3JDb21wb25lbnRzOiBmdW5jdGlvbihjdHlwZSkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLmdldERlYnVnRGF0YSgpO1xuICAgICAgICAgICAgaWYgKGN0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy53aGVyZShjb21wb25lbnRzLCB7J2NhdGVnb3J5JzogY2F0ZWdvcnlFbnVtW2N0eXBlXX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SW5mb0ZvclZpZXdzOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW5mb0ZvckNvbXBvbmVudHMoJ1ZJRVcnKTsgXG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SW5mb0Zvck1hbmFnZXJzOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW5mb0ZvckNvbXBvbmVudHMoJ01BTkFHRVInKTsgXG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0SW5mb0Zvck5hbWVzcGFjZXM6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbmZvRm9yQ29tcG9uZW50cygnTkFNRVNQQUNFJyk7IFxuICAgICAgICB9LFxuXG4gICAgICAgIGhlbHAgOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNwbHVua2pzIERlYnVnZ2VyIENvbW1hbmRzXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZW50KDEpICsgXCItIHByaW50V2FybmluZ3MoKTogUHJpbnRzIGFsbCB3YXJuaW5ncyB0byB0aGUgY29uc29sZS5cIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhpbmRlbnQoMSkgKyBcIi0gcHJpbnRDb21wb25lbnRJbmZvKCk6IFByaW50cyBhbGwgZGVidWcgaW5mbyBhbmQgd2FybmluZ3MgdG8gdGhlIGNvbnNvbGUgYnkgY29tcG9uZW50LlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgxKSArIFwiLSBwcmludFZpZXdJbmZvKCk6IFByaW50cyBkZWJ1ZyBpbmZvIGZvciBhbGwgU3BsdW5rIHZpZXdzLlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgxKSArIFwiLSBwcmludFNlYXJjaE1hbmFnZXJJbmZvKCk6IFByaW50cyBkZWJ1ZyBpbmZvIGZvciBhbGwgU3BsdW5rIHNlYXJjaCBtYW5hZ2Vycy5cIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhpbmRlbnQoMSkgKyBcIi0gcHJpbnRUb2tlbk5hbWVzcGFjZUluZm8oKTogUHJpbnRzIGRlYnVnIGluZm8gZm9yIFNwbHVuayB0b2tlbiBuYW1lc3BhY2VzLlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgxKSArIFwiLSBnZXREZWJ1Z0RhdGEoKTogUmV0dXJucyBhbGwgZGVidWcgbWV0YWRhdGEgZm9yIGNvbXBvbmVudHMgYW5kIG5hbWVzcGFjZXMuXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coaW5kZW50KDEpICsgXCItIGdldEluZm9Gb3JWaWV3cygpOiBSZXR1cm5zIGRlYnVnIG1ldGFkYXRhIGZvciBhbGwgU3BsdW5rIHZpZXdzLlwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGluZGVudCgxKSArIFwiLSBnZXRJbmZvRm9yTWFuYWdlcnMoKTogUmV0dXJucyBkZWJ1ZyBtZXRhZGF0YSBmb3IgYWxsIFNwbHVuayBtYW5hZ2Vycy5cIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhpbmRlbnQoMSkgKyBcIi0gZ2V0SW5mb0Zvck5hbWVzcGFjZXMoKTogUmV0dXJucyBkZWJ1ZyBtZXRhZGF0YSBmb3IgYWxsIFNwbHVuayB0b2tlbiBuYW1lc3BhY2VzLlwiKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIERlYnVnZ2VyO1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvYWxvbW90YW4vRG9jdW1lbnRzL3Ztc2hhcmUvc2NyYXRjaHBhZC9yZWFjdC9vbnNwbHVuay9ub2RlX21vZHVsZXMvQHNwbHVuay9zcGx1bmstd2ViLWNvcmUvc2VhcmNoX21yc3BhcmtsZS9leHBvc2VkL2pzL3NwbHVua2pzL212Yy9kZWJ1Z2dlci5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///132\n");

/***/ }),

/***/ 133:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n    var _ = __webpack_require__(121);\n    var mvc = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"splunkjs/mvc\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    var TokenEscapeString = __webpack_require__(128);\n    var TokenSafeString = __webpack_require__(126);\n    var console = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"util/console\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    var TokenUtils = __webpack_require__(122);\n    var BaseModel = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"models/Base\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n    // Enables logging of when values are propagated between models.\n    var VERBOSE = false;\n\n    // DOC: BaseModel is a private superclass.\n    //      Backbone.Model is the nearest public superclass.\n\n    /**\n     * @constructor\n     * @memberOf splunkjs.mvc\n     * @name TokenAwareModel\n     * @description The **TokenAwareModel** class creates a new token-aware\n     * model with built-in data-binding support.\n     *\n     * The **set** and **get** methods support a \"tokens\" Boolean option.\n     * When `true`, the property is interpreted as a template\n     * that might contain token escapes such as \"$indexName$\".\n     * If set to a template, the property is defined as a computed property\n     * based on the referenced tokens and kept up to date when those token\n     * values change.\n     * @extends splunkjs.mvc.Utils\n     *\n     * @param {Object} attributes - Initial attributes of this model.\n     * @param {Object} options - Options.\n     * @param  {Object} options.tokenNamespace=default -  The name of the namespace to use\n     * when resolving unqualified token references such as `$token$`.\n     * @param options.retainUnmatchedTokens - When `true`, returns the computed\n     * value of the specified property, but with unresolved tokens retained in\n     * the output string. For example, the template \"$first$ $last$\" resolves to\n     * \"Bob $last$\" if only the `$first$` token was defined (and it was \"Bob\").\n     * @param  {Object} options.tokenEscaper - Escaping function that escapes all expanded\n     * token values.\n     * @param  {Object} options.allowNoEscape - Specify whether the $token|n$ no-escape filter can be used.\n     * See TokenUtils#replaceTokens()\n     * @param  {Object} options.* - Interpreted the same way as in {@link splunkjs.mvc.TokenAwareModel#set}.\n     *\n     * @example\n     * // get() and set() methods are always symmetric when using the\n     * // same 'tokens' option (usually 'true' or missing).\n     * this.set('color', '$color$', {tokens: true});\n     * this.get('color', {tokens: true});\n     * >> '$color$'\n     *\n     * // If a property depends on an uninitialized token,\n     * // it takes on an 'undefined' value.\n     * this.get('color');\n     * >> undefined\n     *\n     * // Properties update automatically when their template's\n     * // token(s) are updated.\n     * mvc.Components.getInstance('default').set('color', '#ff0000');\n     * this.get('color');\n     * >> '#ff0000'\n     *\n     * // Setting the literal value of a (non-pushed) property\n     * // will destroy any previous template it may have had.\n     * this.set('color', '#cafeba');\n     * this.get('color');\n     * >> '#cafeba'\n     * this.get('color', {tokens: true});\n     * >> '#cafeba'\n     * mvc.Components.getInstance('default').get('color');\n     * >> '#ff0000'\n     */\n    var TokenAwareModel = BaseModel.extend(/** @lends splunkjs.mvc.TokenAwareModel.prototype */{\n        /**\n         * @deprecated Enables token replacement by default for the <b>set</b> method.\n         *\n         * When <tt>true</tt>, all calls to <b>set</b> implicitly take the option\n         * <tt>{tokens: true}</tt>.\n         */\n        applyTokensByDefault: false,\n\n        /**\n         * @deprecated Enables retrieval of raw (unreplaced) tokens for\n         * the <b>get</b> and <b>toJSON</b> methods.\n         *\n         * When <tt>true</tt>, all calls to <b>get</b> and <b>toJSON</b> implicitly take the\n         * option <tt>{tokens: true}</tt>.\n         */\n        retrieveTokensByDefault: false,\n\n        // Private API:\n        //\n        // @param options._tokenRegistry\n        //                      An alternate token registry to use other than\n        //                      `mvc.Components`. For use by tests only.\n        //\n        // NOTE: Must override constructor() and not initialize()\n        //       because this._templates and listeners need to be\n        //       in place before the first (non-empty) call to set(),\n        //       which the default constructor() does by default.\n        constructor: function(attributes, options) {\n            attributes = attributes || {};\n            options = options || {};\n\n            // Save options whose effects persist beyond the constructor\n            this._tokenNamespace = options.tokenNamespace || undefined;\n            this._retainUnmatchedTokens = options.retainUnmatchedTokens;\n            this._tokenEscaper = options.tokenEscaper || undefined;\n            this._allowNoEscape = options.allowNoEscape;\n            this._tokenRegistry = options._tokenRegistry || mvc.Components;\n            this._applyTokensByDefault =\n                (options.hasOwnProperty('applyTokensByDefault'))\n                    ? options.applyTokensByDefault\n                    : this.applyTokensByDefault;\n            this._retrieveTokensByDefault =\n                (options.hasOwnProperty('retrieveTokensByDefault'))\n                    ? options.retrieveTokensByDefault\n                    : this.retrieveTokensByDefault;\n\n            // Initialize self to empty\n            BaseModel.prototype.constructor.call(this, {});\n            this._templates = new BaseModel({});\n            this._bindings = {};\n            this._pushed_properties = [];\n\n            // When property templates change, update property bindings\n            this.listenTo(this._templates, 'change', function(model, options) {\n                this._updateBindingsForProperties(model.changed, options);\n            });\n\n            // Initialize property values and templates\n            this.set(attributes, options);\n        },\n\n        _updateBindingsForProperties: function(properties, options) {\n            var that = this;\n            _.each(properties, function(propTemplate, propName) {\n                var newBinding;\n                if (propTemplate === undefined) {\n                    newBinding = undefined;\n                } else {\n                    // Create new binding for the property that\n                    // computes its value by taking the template\n                    // and replacing any token escapes that occur.\n                    var tokens = TokenUtils.getTokens(propTemplate, {\n                        tokenNamespace: that._tokenNamespace\n                    });\n\n                    var computeValueFunc = function(_retainUnmatchedTokens) {\n                        // If template is a solitary token escape and the token\n                        // has a non-string value, pass through that value.\n                        // (String values may still need to go through additional\n                        //  escaping based on the filter in the token escape.)\n                        if (TokenUtils.isToken(propTemplate)) {\n                            var token = tokens[0];\n                            var tokenModel = that._tokenRegistry.getInstance(\n                                token.namespace, { create: true });\n                            var tokenValue = tokenModel.get(token.name);\n                            if (!_.isString(tokenValue) && (tokenValue !== undefined)) {\n                                return tokenValue;\n                            }\n                        }\n\n                        var templateSatisfied = _.all(tokens, function(token) {\n                            var tokenModel = that._tokenRegistry.getInstance(\n                                token.namespace, { create: true });\n                            var tokenValue = tokenModel.get(token.name);\n\n                            var filtersSatisfied = _.all(token.filters, function(filter) {\n                                var filterFunc = TokenUtils.getFilter(\n                                    filter.name, that._tokenRegistry);\n                                return (filterFunc !== undefined);\n                            });\n\n                            return (tokenValue !== undefined) && filtersSatisfied;\n                        });\n\n                        var propValue;\n                        if (templateSatisfied || that._retainUnmatchedTokens || _retainUnmatchedTokens) {\n                            propValue = TokenUtils.replaceTokens(\n                                propTemplate, that._tokenRegistry, {\n                                    tokenNamespace: that._tokenNamespace,\n                                    escaper: that._tokenEscaper,\n                                    allowNoEscape: that._allowNoEscape\n                                });\n                        } else {\n                            propValue = undefined;\n                        }\n                        return propValue;\n                    };\n\n                    var items = [];\n                    _.each(tokens, function(token) {\n                        items.push({\n                            namespace: token.namespace,\n                            name: token.name\n                        });\n\n                        _.each(token.filters, function(filter) {\n                            items.push({\n                                namespace: TokenUtils._FILTER_NAMESPACE,\n                                name: filter.name\n                            });\n                        });\n                    });\n\n                    newBinding = {\n                        observes: items,\n                        template: propTemplate,\n                        computeValue: computeValueFunc\n                    };\n                }\n\n                that._setBinding(propName, newBinding, options);\n            });\n        },\n\n        /*\n         * This is an initial implementation of the general Data Binding\n         * feature that Token Binding is implemented on top of.\n         *\n         * Data Binding thinks not in terms of \"tokens\" but rather in terms\n         * of a \"binding\", its \"observed properties\" and its \"target property\".\n         * To reiterate, it should not be aware of tokens.\n         */\n        _setBinding: function(propName, newBinding, options) {\n            var that = this;\n\n            // Destroy the old binding, unregistering old listeners\n            this._disposeBindingListeners(this._bindings[propName]);\n\n            // Register new binding\n            this._bindings[propName] = newBinding;\n\n            if (newBinding !== undefined) {\n                // When observed properties change, update the target property value\n                newBinding._listeners = [];\n                _.each(newBinding.observes, function(observedItem) {\n                    var observedContext = that._tokenRegistry.getInstance(\n                        observedItem.namespace, { create: true });\n                    var observedPropName = observedItem.name;\n                    var listener = function() {\n                        that._pullPropertyValue(propName);\n                    };\n                    that.listenTo(observedContext, 'change:' + observedPropName, listener);\n\n                    // Save listener for later removal\n                    listener.dispose = function() {\n                        that.stopListening(observedContext, 'change:' + observedPropName, listener);\n                    };\n                    newBinding._listeners.push(listener);\n                });\n\n                // If property is push-enabled then push-enable the binding\n                if (this._isPushEnabled(propName)) {\n                    this._configureBindingForPush(propName);\n                }\n\n                /*\n                 * Reconcile the target property's preexisting value (if defined)\n                 * with the observed property(s)' value(s).\n                 *\n                 * If this is a push-pull binding, the target property's value (if defined)\n                 * takes precedence and otherwise the observed property's value is used.\n                 *\n                 * If this is a pull-only binding, just initialize the target property's\n                 * computed value based on the new binding.\n                 */\n                if (this._isPushEnabled(propName) && this.get(propName) !== undefined) {\n                    this._pushPropertyValue(propName, options);\n                } else {\n                    this._pullPropertyValue(propName, options);\n                }\n            }\n        },\n\n        _pullPropertyValue: function(propName, options) {\n            var binding = this._bindings[propName];\n            var propValue = binding.computeValue();\n\n            if (VERBOSE) {\n                console.log('PROPAGATE: ' + propName + ' <- ' + propValue);\n            }\n\n            // We may have gotten a stashed silent value (see set()), so we have\n            // to unstash it.\n            options = options || {};\n            if (options.hasOwnProperty('_silent')) {\n                options.silent = options._silent;\n                delete options._silent;\n            }\n\n            BaseModel.prototype.set.call(this, propName, propValue, options);\n        },\n\n        /**\n         * Marks the specified property as being push-enabled.\n         * A push-enabled property propagates changes to its value\n         * to the single token in its associated template.\n         *\n         * Due to this definition, a push-enabled property must be bound to a\n         * template containing a single token. Attempting to push-enable any\n         * other kind of property is an error.\n         * @param {String} propName - The property name.\n         */\n        enablePush: function(propName) {\n            if (this._isPushEnabled(propName)) {\n                // Already push-enabled\n                return;\n            }\n\n            this._pushed_properties.push(propName);\n\n            // If binding already exists, push-enable it\n            if (this._bindings[propName] !== undefined) {\n                this._configureBindingForPush(propName);\n            }\n        },\n\n        _isPushEnabled: function(propName) {\n            return _.contains(this._pushed_properties, propName);\n        },\n\n        _configureBindingForPush: function(propName) {\n            var binding = this._bindings[propName];\n            if (!TokenUtils.isToken(binding.template)) {\n                // This property's template is not presently bound to a\n                // single token. Therefore there is no token that can\n                // be pushed to yet.\n                return;\n            }\n\n            // Forward value changes to solitary token in template\n            var that = this;\n            var listener = function(model, newValue, options) {\n                that._pushPropertyValue(propName);\n            };\n            this.listenTo(this, 'change:' + propName, listener);\n\n            // Save listener for later removal\n            listener.dispose = function() {\n                that.stopListening(that, 'change:' + propName, listener);\n            };\n            binding._listeners.push(listener);\n        },\n\n        _pushPropertyValue: function(propName, options) {\n            var binding = this._bindings[propName];\n            var newValue = this.get(propName);\n            var observedItem = binding.observes[0];\n            var observedContext = this._tokenRegistry.getInstance(\n                observedItem.namespace, { create: true });\n            var observedPropName = observedItem.name;\n\n            if (VERBOSE) {\n                console.log('PROPAGATE: ' + newValue + ' -> ' + observedPropName);\n            }\n\n            // We may have gotten a stashed silent value (see set()), so we have\n            // to unstash it.\n            options = options || {};\n            if (options.hasOwnProperty('_silent')) {\n                options.silent = options._silent;\n                delete options._silent;\n            }\n\n            observedContext.set(observedPropName, newValue, options);\n        },\n\n        /**\n         * Sets the specified property with a value.\n         *\n         * Values marked with \"`mvc.tokenSafe`\" are interpreted as templates.\n         *\n         * @param {String} key - The name of the property to set.\n         * @param {String} val - The value of the property.\n         * @param {Object} [options] - Options.\n         * @param {Boolean} [options.tokens=false] - Indicates whether to interpret\n         * string values as a template rather than as a literal string. When `true`,\n         * any string values are interpreted as templates rather than literal strings.\n         */\n        set: function(key, val, options) {\n            var that = this;\n\n            // Normalize arguments to (attrs, options)\n            var attrs;\n            if (typeof key === 'object') {\n                attrs = key;\n                options = val;\n            } else {\n                (attrs = {})[key] = val;\n            }\n            options = options || {};\n\n            if (!options.hasOwnProperty('tokens')) {\n                options.tokens = this._applyTokensByDefault;\n            }\n\n            // Collect changes to be made\n            var bulkTemplateSets = {};\n            var bulkTemplateUnsets = [];\n            var bulkSelfSets = {};\n            var queueTemplateSet = function(propName, propTemplate) {\n                bulkTemplateSets[propName] = propTemplate;\n            };\n            var queueLiteralSet = function(propName, propValue) {\n                if (!that._isPushEnabled(propName)) {\n                    // Blank out any preexisting template unless this\n                    // is a pushed property\n                    bulkTemplateUnsets.push(propName);\n                }\n                bulkSelfSets[propName] = propValue;\n            };\n            _.each(attrs, function(propValue, propName) {\n                if (propValue instanceof TokenSafeString) {\n                    // Interpret as template.\n                    queueTemplateSet(propName, propValue.value);\n                } else if (propValue instanceof TokenEscapeString) {\n                    // Interpret as literal value.\n                    queueLiteralSet(propName, propValue.value);\n                } else if (_.isString(propValue) && options.tokens) {\n                    // Interpret as template.\n                    queueTemplateSet(propName, propValue);\n                } else {\n                    // Otherwise interpret as a literal value.\n                    queueLiteralSet(propName, propValue);\n                }\n            });\n\n            // If we do a set/unset on _templates, we can't pass in\n            // {silent: true}, as that will preclude us from getting a change\n            // event, and we won't be able to set up any bindings. Instead,\n            // we stash the silent value in _silent, and only use these\n            // modified options for _templates.\n            var optionsForTemplates = _.clone(options);\n            if (options.hasOwnProperty('silent')) {\n                optionsForTemplates._silent = options.silent;\n                delete optionsForTemplates.silent;\n            }\n\n            // Perform changes in bulk\n            if (!_.isEmpty(bulkTemplateSets)) {\n                this._templates.set(bulkTemplateSets, optionsForTemplates);\n            }\n            if (!_.isEmpty(bulkTemplateUnsets)) {\n                _.each(bulkTemplateUnsets, function(propName) {\n                    if (that._templates && that._templates.has(propName)) {\n                        that._templates.unset(propName, optionsForTemplates);\n                    }\n                });\n            }\n            if (!_.isEmpty(bulkSelfSets)) {\n                BaseModel.prototype.set.call(this, bulkSelfSets, options);\n            }\n        },\n\n        /**\n         * Gets the value of the specified property.\n         *\n         * @param {String} key - The name of the property to get.\n         * @param {Object} [options] - Options.\n         * @param {Boolean} [options.tokens=false] - When `true`, returns the\n         * template string for the specified property rather than its current value.\n         */\n        get: function(key, options) {\n            options || (options = {});\n            if (!options.hasOwnProperty('tokens')) {\n                options.tokens = this._retrieveTokensByDefault;\n            }\n\n            if (options.tokens) {\n                if (this._templates.has(key)) {\n                    return this._templates.get(key);\n                } else {\n                    return TokenUtils.quoteAsTokenString(\n                        BaseModel.prototype.get.call(this, key));\n                }\n            } else {\n                var v = BaseModel.prototype.get.call(this, key);\n                if (v == null && options.retainUnmatchedTokens && this._templates.has(key)) {\n                    v = TokenUtils.replaceTokens(this._templates.get(key), this._tokenRegistry, {\n                        tokenNamespace: this._tokenNamespace,\n                        escaper: this._tokenEscaper,\n                        allowNoEscape: this._allowNoEscape\n                    });\n                }\n                return v;\n            }\n        },\n\n        /**\n         * Returns a dictionary of all properties for this model\n         * with the specified prefix. The prefix is removed in the returned copy.\n         *\n         * Properties that are computed from templates are returned\n         * as an appropriate `mvc.tokenSafe(...)` value.\n         *\n         * For example, if this model has `{'value': 'foo', 'tp_value': 'bar'}`,\n         * and the prefix for extraction is `'tp_'`, the returned dictionary\n         * is `{'value': 'bar'}`.\n         * @param {String} prefix - The prefix.\n         */\n        extractWithPrefix: function(prefix) {\n            var that = this;\n\n            var extractedProperties = {};\n            _.each(_.keys(this.attributes), function(propNameOnThis) {\n                if (propNameOnThis.indexOf(prefix) === 0) {\n                    var propName =\n                        propNameOnThis.substring(prefix.length);\n\n                    // Get property's template or literal value\n                    var propValue;\n                    var templateValue = that.get(propNameOnThis, {tokens: true});\n                    if (templateValue !== undefined) {\n                        propValue = mvc.tokenSafe(templateValue);\n                    } else {\n                        propValue = that.get(propNameOnThis);\n                    }\n\n                    extractedProperties[propName] = propValue;\n                }\n            });\n            return extractedProperties;\n        },\n\n        /**\n         * Returns a copy of all properties for this model.\n         *\n         * @param {Object} [options] - Options.\n         * @param {Boolean} [options.tokens=false] - When `true`, returns the\n         * template string for the specified property rather than its current value.\n         */\n        toJSON: function(options) {\n            options || (options = {});\n            if (!options.hasOwnProperty('tokens')) {\n                options.tokens = this._retrieveTokensByDefault;\n            }\n\n            if (options.tokens) {\n                var that = this;\n\n                var result = {};\n                // Fill in quoted literals\n                _.each(this.attributes, function(value, key) {\n                    result[key] = that.get(key, {tokens: true});\n                });\n                // Fill in real templates\n                result = _.extend(result, this._templates.toJSON());\n                return result;\n            } else {\n                return BaseModel.prototype.toJSON.apply(this, arguments);\n            }\n        },\n\n        dispose: function() {\n            this._templates.deepOff();\n            _.each(this._bindings, this._disposeBindingListeners);\n            this._bindings = {};\n            this.deepOff();\n        },\n\n        _disposeBindingListeners: function(binding) {\n            if (binding) {\n                _.each(binding._listeners, function(listener) {\n                    listener.dispose();\n                });\n                binding._listeners = [];\n            }\n        }\n    });\n\n    /*\n     * Creates an empty report model for use by low-level core UI views.\n     *\n     * Core UI views expect that templated properties can always be\n     * accessed and that they retain unmatched tokens. It is also assumed\n     * that templated properties can be set without specifying `{tokens: true}`\n     * explicitly.\n     *\n     * Package-private.\n     */\n    TokenAwareModel._createReportModel = function(attributes, options) {\n        options = options || {};\n        return new TokenAwareModel(attributes || {}, _.extend({\n            applyTokensByDefault: true,\n            retainUnmatchedTokens: true\n        }, options));\n    };\n\n    return TokenAwareModel;\n}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2Fsb21vdGFuL0RvY3VtZW50cy92bXNoYXJlL3NjcmF0Y2hwYWQvcmVhY3Qvb25zcGx1bmsvbm9kZV9tb2R1bGVzL0BzcGx1bmsvc3BsdW5rLXdlYi1jb3JlL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zcGx1bmtqcy9tdmMvdG9rZW5hd2FyZW1vZGVsLmpzPzgzMTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEscUVBQU87QUFDUCxZQUFZLG1CQUFPLENBQUMsR0FBWTtBQUNoQyxjQUFjLG1CQUFPLENBQUMsd0lBQWM7QUFDcEMsNEJBQTRCLG1CQUFPLENBQUMsR0FBcUI7QUFDekQsMEJBQTBCLG1CQUFPLENBQUMsR0FBbUI7QUFDckQsa0JBQWtCLG1CQUFPLENBQUMsd0lBQWM7QUFDeEMscUJBQXFCLG1CQUFPLENBQUMsR0FBYztBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQyx1SUFBYTs7QUFFekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxnQkFBZ0IsT0FBTyw2Q0FBNkMsdUNBQXVDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pELDhDQUE4QztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxlQUFlO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtDQUFrQztBQUM5RTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRUFBa0UsYUFBYTtBQUMvRTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGFBQWE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxDQUFDO0FBQUEsb0dBQUMiLCJmaWxlIjoiMTMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIHZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuICAgIHZhciBtdmMgPSByZXF1aXJlKFwic3BsdW5ranMvbXZjXCIpO1xuICAgIHZhciBUb2tlbkVzY2FwZVN0cmluZyA9IHJlcXVpcmUoXCIuL3Rva2VuZXNjYXBlc3RyaW5nXCIpO1xuICAgIHZhciBUb2tlblNhZmVTdHJpbmcgPSByZXF1aXJlKFwiLi90b2tlbnNhZmVzdHJpbmdcIik7XG4gICAgdmFyIGNvbnNvbGUgPSByZXF1aXJlKFwidXRpbC9jb25zb2xlXCIpO1xuICAgIHZhciBUb2tlblV0aWxzID0gcmVxdWlyZSgnLi90b2tlbnV0aWxzJyk7XG4gICAgdmFyIEJhc2VNb2RlbCA9IHJlcXVpcmUoJ21vZGVscy9CYXNlJyk7XG5cbiAgICAvLyBFbmFibGVzIGxvZ2dpbmcgb2Ygd2hlbiB2YWx1ZXMgYXJlIHByb3BhZ2F0ZWQgYmV0d2VlbiBtb2RlbHMuXG4gICAgdmFyIFZFUkJPU0UgPSBmYWxzZTtcblxuICAgIC8vIERPQzogQmFzZU1vZGVsIGlzIGEgcHJpdmF0ZSBzdXBlcmNsYXNzLlxuICAgIC8vICAgICAgQmFja2JvbmUuTW9kZWwgaXMgdGhlIG5lYXJlc3QgcHVibGljIHN1cGVyY2xhc3MuXG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2Ygc3BsdW5ranMubXZjXG4gICAgICogQG5hbWUgVG9rZW5Bd2FyZU1vZGVsXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSAqKlRva2VuQXdhcmVNb2RlbCoqIGNsYXNzIGNyZWF0ZXMgYSBuZXcgdG9rZW4tYXdhcmVcbiAgICAgKiBtb2RlbCB3aXRoIGJ1aWx0LWluIGRhdGEtYmluZGluZyBzdXBwb3J0LlxuICAgICAqXG4gICAgICogVGhlICoqc2V0KiogYW5kICoqZ2V0KiogbWV0aG9kcyBzdXBwb3J0IGEgXCJ0b2tlbnNcIiBCb29sZWFuIG9wdGlvbi5cbiAgICAgKiBXaGVuIGB0cnVlYCwgdGhlIHByb3BlcnR5IGlzIGludGVycHJldGVkIGFzIGEgdGVtcGxhdGVcbiAgICAgKiB0aGF0IG1pZ2h0IGNvbnRhaW4gdG9rZW4gZXNjYXBlcyBzdWNoIGFzIFwiJGluZGV4TmFtZSRcIi5cbiAgICAgKiBJZiBzZXQgdG8gYSB0ZW1wbGF0ZSwgdGhlIHByb3BlcnR5IGlzIGRlZmluZWQgYXMgYSBjb21wdXRlZCBwcm9wZXJ0eVxuICAgICAqIGJhc2VkIG9uIHRoZSByZWZlcmVuY2VkIHRva2VucyBhbmQga2VwdCB1cCB0byBkYXRlIHdoZW4gdGhvc2UgdG9rZW5cbiAgICAgKiB2YWx1ZXMgY2hhbmdlLlxuICAgICAqIEBleHRlbmRzIHNwbHVua2pzLm12Yy5VdGlsc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgLSBJbml0aWFsIGF0dHJpYnV0ZXMgb2YgdGhpcyBtb2RlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zLnRva2VuTmFtZXNwYWNlPWRlZmF1bHQgLSAgVGhlIG5hbWUgb2YgdGhlIG5hbWVzcGFjZSB0byB1c2VcbiAgICAgKiB3aGVuIHJlc29sdmluZyB1bnF1YWxpZmllZCB0b2tlbiByZWZlcmVuY2VzIHN1Y2ggYXMgYCR0b2tlbiRgLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJldGFpblVubWF0Y2hlZFRva2VucyAtIFdoZW4gYHRydWVgLCByZXR1cm5zIHRoZSBjb21wdXRlZFxuICAgICAqIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydHksIGJ1dCB3aXRoIHVucmVzb2x2ZWQgdG9rZW5zIHJldGFpbmVkIGluXG4gICAgICogdGhlIG91dHB1dCBzdHJpbmcuIEZvciBleGFtcGxlLCB0aGUgdGVtcGxhdGUgXCIkZmlyc3QkICRsYXN0JFwiIHJlc29sdmVzIHRvXG4gICAgICogXCJCb2IgJGxhc3QkXCIgaWYgb25seSB0aGUgYCRmaXJzdCRgIHRva2VuIHdhcyBkZWZpbmVkIChhbmQgaXQgd2FzIFwiQm9iXCIpLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucy50b2tlbkVzY2FwZXIgLSBFc2NhcGluZyBmdW5jdGlvbiB0aGF0IGVzY2FwZXMgYWxsIGV4cGFuZGVkXG4gICAgICogdG9rZW4gdmFsdWVzLlxuICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucy5hbGxvd05vRXNjYXBlIC0gU3BlY2lmeSB3aGV0aGVyIHRoZSAkdG9rZW58biQgbm8tZXNjYXBlIGZpbHRlciBjYW4gYmUgdXNlZC5cbiAgICAgKiBTZWUgVG9rZW5VdGlscyNyZXBsYWNlVG9rZW5zKClcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMuKiAtIEludGVycHJldGVkIHRoZSBzYW1lIHdheSBhcyBpbiB7QGxpbmsgc3BsdW5ranMubXZjLlRva2VuQXdhcmVNb2RlbCNzZXR9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQoKSBhbmQgc2V0KCkgbWV0aG9kcyBhcmUgYWx3YXlzIHN5bW1ldHJpYyB3aGVuIHVzaW5nIHRoZVxuICAgICAqIC8vIHNhbWUgJ3Rva2Vucycgb3B0aW9uICh1c3VhbGx5ICd0cnVlJyBvciBtaXNzaW5nKS5cbiAgICAgKiB0aGlzLnNldCgnY29sb3InLCAnJGNvbG9yJCcsIHt0b2tlbnM6IHRydWV9KTtcbiAgICAgKiB0aGlzLmdldCgnY29sb3InLCB7dG9rZW5zOiB0cnVlfSk7XG4gICAgICogPj4gJyRjb2xvciQnXG4gICAgICpcbiAgICAgKiAvLyBJZiBhIHByb3BlcnR5IGRlcGVuZHMgb24gYW4gdW5pbml0aWFsaXplZCB0b2tlbixcbiAgICAgKiAvLyBpdCB0YWtlcyBvbiBhbiAndW5kZWZpbmVkJyB2YWx1ZS5cbiAgICAgKiB0aGlzLmdldCgnY29sb3InKTtcbiAgICAgKiA+PiB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIC8vIFByb3BlcnRpZXMgdXBkYXRlIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGVpciB0ZW1wbGF0ZSdzXG4gICAgICogLy8gdG9rZW4ocykgYXJlIHVwZGF0ZWQuXG4gICAgICogbXZjLkNvbXBvbmVudHMuZ2V0SW5zdGFuY2UoJ2RlZmF1bHQnKS5zZXQoJ2NvbG9yJywgJyNmZjAwMDAnKTtcbiAgICAgKiB0aGlzLmdldCgnY29sb3InKTtcbiAgICAgKiA+PiAnI2ZmMDAwMCdcbiAgICAgKlxuICAgICAqIC8vIFNldHRpbmcgdGhlIGxpdGVyYWwgdmFsdWUgb2YgYSAobm9uLXB1c2hlZCkgcHJvcGVydHlcbiAgICAgKiAvLyB3aWxsIGRlc3Ryb3kgYW55IHByZXZpb3VzIHRlbXBsYXRlIGl0IG1heSBoYXZlIGhhZC5cbiAgICAgKiB0aGlzLnNldCgnY29sb3InLCAnI2NhZmViYScpO1xuICAgICAqIHRoaXMuZ2V0KCdjb2xvcicpO1xuICAgICAqID4+ICcjY2FmZWJhJ1xuICAgICAqIHRoaXMuZ2V0KCdjb2xvcicsIHt0b2tlbnM6IHRydWV9KTtcbiAgICAgKiA+PiAnI2NhZmViYSdcbiAgICAgKiBtdmMuQ29tcG9uZW50cy5nZXRJbnN0YW5jZSgnZGVmYXVsdCcpLmdldCgnY29sb3InKTtcbiAgICAgKiA+PiAnI2ZmMDAwMCdcbiAgICAgKi9cbiAgICB2YXIgVG9rZW5Bd2FyZU1vZGVsID0gQmFzZU1vZGVsLmV4dGVuZCgvKiogQGxlbmRzIHNwbHVua2pzLm12Yy5Ub2tlbkF3YXJlTW9kZWwucHJvdG90eXBlICove1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgRW5hYmxlcyB0b2tlbiByZXBsYWNlbWVudCBieSBkZWZhdWx0IGZvciB0aGUgPGI+c2V0PC9iPiBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZW4gPHR0PnRydWU8L3R0PiwgYWxsIGNhbGxzIHRvIDxiPnNldDwvYj4gaW1wbGljaXRseSB0YWtlIHRoZSBvcHRpb25cbiAgICAgICAgICogPHR0Pnt0b2tlbnM6IHRydWV9PC90dD4uXG4gICAgICAgICAqL1xuICAgICAgICBhcHBseVRva2Vuc0J5RGVmYXVsdDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIEVuYWJsZXMgcmV0cmlldmFsIG9mIHJhdyAodW5yZXBsYWNlZCkgdG9rZW5zIGZvclxuICAgICAgICAgKiB0aGUgPGI+Z2V0PC9iPiBhbmQgPGI+dG9KU09OPC9iPiBtZXRob2RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIDx0dD50cnVlPC90dD4sIGFsbCBjYWxscyB0byA8Yj5nZXQ8L2I+IGFuZCA8Yj50b0pTT048L2I+IGltcGxpY2l0bHkgdGFrZSB0aGVcbiAgICAgICAgICogb3B0aW9uIDx0dD57dG9rZW5zOiB0cnVlfTwvdHQ+LlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0cmlldmVUb2tlbnNCeURlZmF1bHQ6IGZhbHNlLFxuXG4gICAgICAgIC8vIFByaXZhdGUgQVBJOlxuICAgICAgICAvL1xuICAgICAgICAvLyBAcGFyYW0gb3B0aW9ucy5fdG9rZW5SZWdpc3RyeVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICBBbiBhbHRlcm5hdGUgdG9rZW4gcmVnaXN0cnkgdG8gdXNlIG90aGVyIHRoYW5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgYG12Yy5Db21wb25lbnRzYC4gRm9yIHVzZSBieSB0ZXN0cyBvbmx5LlxuICAgICAgICAvL1xuICAgICAgICAvLyBOT1RFOiBNdXN0IG92ZXJyaWRlIGNvbnN0cnVjdG9yKCkgYW5kIG5vdCBpbml0aWFsaXplKClcbiAgICAgICAgLy8gICAgICAgYmVjYXVzZSB0aGlzLl90ZW1wbGF0ZXMgYW5kIGxpc3RlbmVycyBuZWVkIHRvIGJlXG4gICAgICAgIC8vICAgICAgIGluIHBsYWNlIGJlZm9yZSB0aGUgZmlyc3QgKG5vbi1lbXB0eSkgY2FsbCB0byBzZXQoKSxcbiAgICAgICAgLy8gICAgICAgd2hpY2ggdGhlIGRlZmF1bHQgY29uc3RydWN0b3IoKSBkb2VzIGJ5IGRlZmF1bHQuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICAvLyBTYXZlIG9wdGlvbnMgd2hvc2UgZWZmZWN0cyBwZXJzaXN0IGJleW9uZCB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuTmFtZXNwYWNlID0gb3B0aW9ucy50b2tlbk5hbWVzcGFjZSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9yZXRhaW5Vbm1hdGNoZWRUb2tlbnMgPSBvcHRpb25zLnJldGFpblVubWF0Y2hlZFRva2VucztcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuRXNjYXBlciA9IG9wdGlvbnMudG9rZW5Fc2NhcGVyIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2FsbG93Tm9Fc2NhcGUgPSBvcHRpb25zLmFsbG93Tm9Fc2NhcGU7XG4gICAgICAgICAgICB0aGlzLl90b2tlblJlZ2lzdHJ5ID0gb3B0aW9ucy5fdG9rZW5SZWdpc3RyeSB8fCBtdmMuQ29tcG9uZW50cztcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5VG9rZW5zQnlEZWZhdWx0ID1cbiAgICAgICAgICAgICAgICAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnYXBwbHlUb2tlbnNCeURlZmF1bHQnKSlcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmFwcGx5VG9rZW5zQnlEZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5hcHBseVRva2Vuc0J5RGVmYXVsdDtcbiAgICAgICAgICAgIHRoaXMuX3JldHJpZXZlVG9rZW5zQnlEZWZhdWx0ID1cbiAgICAgICAgICAgICAgICAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncmV0cmlldmVUb2tlbnNCeURlZmF1bHQnKSlcbiAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLnJldHJpZXZlVG9rZW5zQnlEZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5yZXRyaWV2ZVRva2Vuc0J5RGVmYXVsdDtcblxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBzZWxmIHRvIGVtcHR5XG4gICAgICAgICAgICBCYXNlTW9kZWwucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywge30pO1xuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGVzID0gbmV3IEJhc2VNb2RlbCh7fSk7XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5ncyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5fcHVzaGVkX3Byb3BlcnRpZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gV2hlbiBwcm9wZXJ0eSB0ZW1wbGF0ZXMgY2hhbmdlLCB1cGRhdGUgcHJvcGVydHkgYmluZGluZ3NcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8odGhpcy5fdGVtcGxhdGVzLCAnY2hhbmdlJywgZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVCaW5kaW5nc0ZvclByb3BlcnRpZXMobW9kZWwuY2hhbmdlZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBwcm9wZXJ0eSB2YWx1ZXMgYW5kIHRlbXBsYXRlc1xuICAgICAgICAgICAgdGhpcy5zZXQoYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZUJpbmRpbmdzRm9yUHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgXy5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BUZW1wbGF0ZSwgcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QmluZGluZztcbiAgICAgICAgICAgICAgICBpZiAocHJvcFRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3QmluZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IGJpbmRpbmcgZm9yIHRoZSBwcm9wZXJ0eSB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXB1dGVzIGl0cyB2YWx1ZSBieSB0YWtpbmcgdGhlIHRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXBsYWNpbmcgYW55IHRva2VuIGVzY2FwZXMgdGhhdCBvY2N1ci5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VucyA9IFRva2VuVXRpbHMuZ2V0VG9rZW5zKHByb3BUZW1wbGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5OYW1lc3BhY2U6IHRoYXQuX3Rva2VuTmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wdXRlVmFsdWVGdW5jID0gZnVuY3Rpb24oX3JldGFpblVubWF0Y2hlZFRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGVtcGxhdGUgaXMgYSBzb2xpdGFyeSB0b2tlbiBlc2NhcGUgYW5kIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFzIGEgbm9uLXN0cmluZyB2YWx1ZSwgcGFzcyB0aHJvdWdoIHRoYXQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoU3RyaW5nIHZhbHVlcyBtYXkgc3RpbGwgbmVlZCB0byBnbyB0aHJvdWdoIGFkZGl0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBlc2NhcGluZyBiYXNlZCBvbiB0aGUgZmlsdGVyIGluIHRoZSB0b2tlbiBlc2NhcGUuKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFRva2VuVXRpbHMuaXNUb2tlbihwcm9wVGVtcGxhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbk1vZGVsID0gdGhhdC5fdG9rZW5SZWdpc3RyeS5nZXRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubmFtZXNwYWNlLCB7IGNyZWF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5WYWx1ZSA9IHRva2VuTW9kZWwuZ2V0KHRva2VuLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghXy5pc1N0cmluZyh0b2tlblZhbHVlKSAmJiAodG9rZW5WYWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5WYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVNhdGlzZmllZCA9IF8uYWxsKHRva2VucywgZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5Nb2RlbCA9IHRoYXQuX3Rva2VuUmVnaXN0cnkuZ2V0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLm5hbWVzcGFjZSwgeyBjcmVhdGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuVmFsdWUgPSB0b2tlbk1vZGVsLmdldCh0b2tlbi5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJzU2F0aXNmaWVkID0gXy5hbGwodG9rZW4uZmlsdGVycywgZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJGdW5jID0gVG9rZW5VdGlscy5nZXRGaWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIubmFtZSwgdGhhdC5fdG9rZW5SZWdpc3RyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZmlsdGVyRnVuYyAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodG9rZW5WYWx1ZSAhPT0gdW5kZWZpbmVkKSAmJiBmaWx0ZXJzU2F0aXNmaWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVTYXRpc2ZpZWQgfHwgdGhhdC5fcmV0YWluVW5tYXRjaGVkVG9rZW5zIHx8IF9yZXRhaW5Vbm1hdGNoZWRUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBUb2tlblV0aWxzLnJlcGxhY2VUb2tlbnMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BUZW1wbGF0ZSwgdGhhdC5fdG9rZW5SZWdpc3RyeSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5OYW1lc3BhY2U6IHRoYXQuX3Rva2VuTmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlcjogdGhhdC5fdG9rZW5Fc2NhcGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dOb0VzY2FwZTogdGhhdC5fYWxsb3dOb0VzY2FwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKHRva2VucywgZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogdG9rZW4ubmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRva2VuLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2godG9rZW4uZmlsdGVycywgZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogVG9rZW5VdGlscy5fRklMVEVSX05BTUVTUEFDRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZmlsdGVyLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBuZXdCaW5kaW5nID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXM6IGl0ZW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IHByb3BUZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVWYWx1ZTogY29tcHV0ZVZhbHVlRnVuY1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoYXQuX3NldEJpbmRpbmcocHJvcE5hbWUsIG5ld0JpbmRpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICogVGhpcyBpcyBhbiBpbml0aWFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSBnZW5lcmFsIERhdGEgQmluZGluZ1xuICAgICAgICAgKiBmZWF0dXJlIHRoYXQgVG9rZW4gQmluZGluZyBpcyBpbXBsZW1lbnRlZCBvbiB0b3Agb2YuXG4gICAgICAgICAqXG4gICAgICAgICAqIERhdGEgQmluZGluZyB0aGlua3Mgbm90IGluIHRlcm1zIG9mIFwidG9rZW5zXCIgYnV0IHJhdGhlciBpbiB0ZXJtc1xuICAgICAgICAgKiBvZiBhIFwiYmluZGluZ1wiLCBpdHMgXCJvYnNlcnZlZCBwcm9wZXJ0aWVzXCIgYW5kIGl0cyBcInRhcmdldCBwcm9wZXJ0eVwiLlxuICAgICAgICAgKiBUbyByZWl0ZXJhdGUsIGl0IHNob3VsZCBub3QgYmUgYXdhcmUgb2YgdG9rZW5zLlxuICAgICAgICAgKi9cbiAgICAgICAgX3NldEJpbmRpbmc6IGZ1bmN0aW9uKHByb3BOYW1lLCBuZXdCaW5kaW5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIERlc3Ryb3kgdGhlIG9sZCBiaW5kaW5nLCB1bnJlZ2lzdGVyaW5nIG9sZCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VCaW5kaW5nTGlzdGVuZXJzKHRoaXMuX2JpbmRpbmdzW3Byb3BOYW1lXSk7XG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIG5ldyBiaW5kaW5nXG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5nc1twcm9wTmFtZV0gPSBuZXdCaW5kaW5nO1xuXG4gICAgICAgICAgICBpZiAobmV3QmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBvYnNlcnZlZCBwcm9wZXJ0aWVzIGNoYW5nZSwgdXBkYXRlIHRoZSB0YXJnZXQgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICAgICAgICBuZXdCaW5kaW5nLl9saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBfLmVhY2gobmV3QmluZGluZy5vYnNlcnZlcywgZnVuY3Rpb24ob2JzZXJ2ZWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlZENvbnRleHQgPSB0aGF0Ll90b2tlblJlZ2lzdHJ5LmdldEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZWRJdGVtLm5hbWVzcGFjZSwgeyBjcmVhdGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlZFByb3BOYW1lID0gb2JzZXJ2ZWRJdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fcHVsbFByb3BlcnR5VmFsdWUocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGF0Lmxpc3RlblRvKG9ic2VydmVkQ29udGV4dCwgJ2NoYW5nZTonICsgb2JzZXJ2ZWRQcm9wTmFtZSwgbGlzdGVuZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgbGlzdGVuZXIgZm9yIGxhdGVyIHJlbW92YWxcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zdG9wTGlzdGVuaW5nKG9ic2VydmVkQ29udGV4dCwgJ2NoYW5nZTonICsgb2JzZXJ2ZWRQcm9wTmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuZXdCaW5kaW5nLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBwcm9wZXJ0eSBpcyBwdXNoLWVuYWJsZWQgdGhlbiBwdXNoLWVuYWJsZSB0aGUgYmluZGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1B1c2hFbmFibGVkKHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25maWd1cmVCaW5kaW5nRm9yUHVzaChwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBSZWNvbmNpbGUgdGhlIHRhcmdldCBwcm9wZXJ0eSdzIHByZWV4aXN0aW5nIHZhbHVlIChpZiBkZWZpbmVkKVxuICAgICAgICAgICAgICAgICAqIHdpdGggdGhlIG9ic2VydmVkIHByb3BlcnR5KHMpJyB2YWx1ZShzKS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYSBwdXNoLXB1bGwgYmluZGluZywgdGhlIHRhcmdldCBwcm9wZXJ0eSdzIHZhbHVlIChpZiBkZWZpbmVkKVxuICAgICAgICAgICAgICAgICAqIHRha2VzIHByZWNlZGVuY2UgYW5kIG90aGVyd2lzZSB0aGUgb2JzZXJ2ZWQgcHJvcGVydHkncyB2YWx1ZSBpcyB1c2VkLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhIHB1bGwtb25seSBiaW5kaW5nLCBqdXN0IGluaXRpYWxpemUgdGhlIHRhcmdldCBwcm9wZXJ0eSdzXG4gICAgICAgICAgICAgICAgICogY29tcHV0ZWQgdmFsdWUgYmFzZWQgb24gdGhlIG5ldyBiaW5kaW5nLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1B1c2hFbmFibGVkKHByb3BOYW1lKSAmJiB0aGlzLmdldChwcm9wTmFtZSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXNoUHJvcGVydHlWYWx1ZShwcm9wTmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVsbFByb3BlcnR5VmFsdWUocHJvcE5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfcHVsbFByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uKHByb3BOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgYmluZGluZyA9IHRoaXMuX2JpbmRpbmdzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBiaW5kaW5nLmNvbXB1dGVWYWx1ZSgpO1xuXG4gICAgICAgICAgICBpZiAoVkVSQk9TRSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQUk9QQUdBVEU6ICcgKyBwcm9wTmFtZSArICcgPC0gJyArIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIG1heSBoYXZlIGdvdHRlbiBhIHN0YXNoZWQgc2lsZW50IHZhbHVlIChzZWUgc2V0KCkpLCBzbyB3ZSBoYXZlXG4gICAgICAgICAgICAvLyB0byB1bnN0YXNoIGl0LlxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnX3NpbGVudCcpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaWxlbnQgPSBvcHRpb25zLl9zaWxlbnQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuX3NpbGVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQmFzZU1vZGVsLnByb3RvdHlwZS5zZXQuY2FsbCh0aGlzLCBwcm9wTmFtZSwgcHJvcFZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBhcyBiZWluZyBwdXNoLWVuYWJsZWQuXG4gICAgICAgICAqIEEgcHVzaC1lbmFibGVkIHByb3BlcnR5IHByb3BhZ2F0ZXMgY2hhbmdlcyB0byBpdHMgdmFsdWVcbiAgICAgICAgICogdG8gdGhlIHNpbmdsZSB0b2tlbiBpbiBpdHMgYXNzb2NpYXRlZCB0ZW1wbGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogRHVlIHRvIHRoaXMgZGVmaW5pdGlvbiwgYSBwdXNoLWVuYWJsZWQgcHJvcGVydHkgbXVzdCBiZSBib3VuZCB0byBhXG4gICAgICAgICAqIHRlbXBsYXRlIGNvbnRhaW5pbmcgYSBzaW5nbGUgdG9rZW4uIEF0dGVtcHRpbmcgdG8gcHVzaC1lbmFibGUgYW55XG4gICAgICAgICAqIG90aGVyIGtpbmQgb2YgcHJvcGVydHkgaXMgYW4gZXJyb3IuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSAtIFRoZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgZW5hYmxlUHVzaDogZnVuY3Rpb24ocHJvcE5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1B1c2hFbmFibGVkKHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgcHVzaC1lbmFibGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9wdXNoZWRfcHJvcGVydGllcy5wdXNoKHByb3BOYW1lKTtcblxuICAgICAgICAgICAgLy8gSWYgYmluZGluZyBhbHJlYWR5IGV4aXN0cywgcHVzaC1lbmFibGUgaXRcbiAgICAgICAgICAgIGlmICh0aGlzLl9iaW5kaW5nc1twcm9wTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbmZpZ3VyZUJpbmRpbmdGb3JQdXNoKHByb3BOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfaXNQdXNoRW5hYmxlZDogZnVuY3Rpb24ocHJvcE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfLmNvbnRhaW5zKHRoaXMuX3B1c2hlZF9wcm9wZXJ0aWVzLCBwcm9wTmFtZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NvbmZpZ3VyZUJpbmRpbmdGb3JQdXNoOiBmdW5jdGlvbihwcm9wTmFtZSkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLl9iaW5kaW5nc1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAoIVRva2VuVXRpbHMuaXNUb2tlbihiaW5kaW5nLnRlbXBsYXRlKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJvcGVydHkncyB0ZW1wbGF0ZSBpcyBub3QgcHJlc2VudGx5IGJvdW5kIHRvIGFcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgdG9rZW4uIFRoZXJlZm9yZSB0aGVyZSBpcyBubyB0b2tlbiB0aGF0IGNhblxuICAgICAgICAgICAgICAgIC8vIGJlIHB1c2hlZCB0byB5ZXQuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3J3YXJkIHZhbHVlIGNoYW5nZXMgdG8gc29saXRhcnkgdG9rZW4gaW4gdGVtcGxhdGVcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKG1vZGVsLCBuZXdWYWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoYXQuX3B1c2hQcm9wZXJ0eVZhbHVlKHByb3BOYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMsICdjaGFuZ2U6JyArIHByb3BOYW1lLCBsaXN0ZW5lcik7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgbGlzdGVuZXIgZm9yIGxhdGVyIHJlbW92YWxcbiAgICAgICAgICAgIGxpc3RlbmVyLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnN0b3BMaXN0ZW5pbmcodGhhdCwgJ2NoYW5nZTonICsgcHJvcE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBiaW5kaW5nLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3B1c2hQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbihwcm9wTmFtZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLl9iaW5kaW5nc1twcm9wTmFtZV07XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmdldChwcm9wTmFtZSk7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZWRJdGVtID0gYmluZGluZy5vYnNlcnZlc1swXTtcbiAgICAgICAgICAgIHZhciBvYnNlcnZlZENvbnRleHQgPSB0aGlzLl90b2tlblJlZ2lzdHJ5LmdldEluc3RhbmNlKFxuICAgICAgICAgICAgICAgIG9ic2VydmVkSXRlbS5uYW1lc3BhY2UsIHsgY3JlYXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgdmFyIG9ic2VydmVkUHJvcE5hbWUgPSBvYnNlcnZlZEl0ZW0ubmFtZTtcblxuICAgICAgICAgICAgaWYgKFZFUkJPU0UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUFJPUEFHQVRFOiAnICsgbmV3VmFsdWUgKyAnIC0+ICcgKyBvYnNlcnZlZFByb3BOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgbWF5IGhhdmUgZ290dGVuIGEgc3Rhc2hlZCBzaWxlbnQgdmFsdWUgKHNlZSBzZXQoKSksIHNvIHdlIGhhdmVcbiAgICAgICAgICAgIC8vIHRvIHVuc3Rhc2ggaXQuXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdfc2lsZW50JykpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNpbGVudCA9IG9wdGlvbnMuX3NpbGVudDtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5fc2lsZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYnNlcnZlZENvbnRleHQuc2V0KG9ic2VydmVkUHJvcE5hbWUsIG5ld1ZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IHdpdGggYSB2YWx1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVmFsdWVzIG1hcmtlZCB3aXRoIFwiYG12Yy50b2tlblNhZmVgXCIgYXJlIGludGVycHJldGVkIGFzIHRlbXBsYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgLSBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucy5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50b2tlbnM9ZmFsc2VdIC0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gaW50ZXJwcmV0XG4gICAgICAgICAqIHN0cmluZyB2YWx1ZXMgYXMgYSB0ZW1wbGF0ZSByYXRoZXIgdGhhbiBhcyBhIGxpdGVyYWwgc3RyaW5nLiBXaGVuIGB0cnVlYCxcbiAgICAgICAgICogYW55IHN0cmluZyB2YWx1ZXMgYXJlIGludGVycHJldGVkIGFzIHRlbXBsYXRlcyByYXRoZXIgdGhhbiBsaXRlcmFsIHN0cmluZ3MuXG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBhcmd1bWVudHMgdG8gKGF0dHJzLCBvcHRpb25zKVxuICAgICAgICAgICAgdmFyIGF0dHJzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KCd0b2tlbnMnKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudG9rZW5zID0gdGhpcy5fYXBwbHlUb2tlbnNCeURlZmF1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbGxlY3QgY2hhbmdlcyB0byBiZSBtYWRlXG4gICAgICAgICAgICB2YXIgYnVsa1RlbXBsYXRlU2V0cyA9IHt9O1xuICAgICAgICAgICAgdmFyIGJ1bGtUZW1wbGF0ZVVuc2V0cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGJ1bGtTZWxmU2V0cyA9IHt9O1xuICAgICAgICAgICAgdmFyIHF1ZXVlVGVtcGxhdGVTZXQgPSBmdW5jdGlvbihwcm9wTmFtZSwgcHJvcFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgYnVsa1RlbXBsYXRlU2V0c1twcm9wTmFtZV0gPSBwcm9wVGVtcGxhdGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHF1ZXVlTGl0ZXJhbFNldCA9IGZ1bmN0aW9uKHByb3BOYW1lLCBwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoYXQuX2lzUHVzaEVuYWJsZWQocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJsYW5rIG91dCBhbnkgcHJlZXhpc3RpbmcgdGVtcGxhdGUgdW5sZXNzIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgYSBwdXNoZWQgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgYnVsa1RlbXBsYXRlVW5zZXRzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWxrU2VsZlNldHNbcHJvcE5hbWVdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF8uZWFjaChhdHRycywgZnVuY3Rpb24ocHJvcFZhbHVlLCBwcm9wTmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBUb2tlblNhZmVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJwcmV0IGFzIHRlbXBsYXRlLlxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVRlbXBsYXRlU2V0KHByb3BOYW1lLCBwcm9wVmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgVG9rZW5Fc2NhcGVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJwcmV0IGFzIGxpdGVyYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlTGl0ZXJhbFNldChwcm9wTmFtZSwgcHJvcFZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcocHJvcFZhbHVlKSAmJiBvcHRpb25zLnRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcnByZXQgYXMgdGVtcGxhdGUuXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlVGVtcGxhdGVTZXQocHJvcE5hbWUsIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGludGVycHJldCBhcyBhIGxpdGVyYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlTGl0ZXJhbFNldChwcm9wTmFtZSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gSWYgd2UgZG8gYSBzZXQvdW5zZXQgb24gX3RlbXBsYXRlcywgd2UgY2FuJ3QgcGFzcyBpblxuICAgICAgICAgICAgLy8ge3NpbGVudDogdHJ1ZX0sIGFzIHRoYXQgd2lsbCBwcmVjbHVkZSB1cyBmcm9tIGdldHRpbmcgYSBjaGFuZ2VcbiAgICAgICAgICAgIC8vIGV2ZW50LCBhbmQgd2Ugd29uJ3QgYmUgYWJsZSB0byBzZXQgdXAgYW55IGJpbmRpbmdzLiBJbnN0ZWFkLFxuICAgICAgICAgICAgLy8gd2Ugc3Rhc2ggdGhlIHNpbGVudCB2YWx1ZSBpbiBfc2lsZW50LCBhbmQgb25seSB1c2UgdGhlc2VcbiAgICAgICAgICAgIC8vIG1vZGlmaWVkIG9wdGlvbnMgZm9yIF90ZW1wbGF0ZXMuXG4gICAgICAgICAgICB2YXIgb3B0aW9uc0ZvclRlbXBsYXRlcyA9IF8uY2xvbmUob3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2lsZW50JykpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zRm9yVGVtcGxhdGVzLl9zaWxlbnQgPSBvcHRpb25zLnNpbGVudDtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uc0ZvclRlbXBsYXRlcy5zaWxlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFBlcmZvcm0gY2hhbmdlcyBpbiBidWxrXG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eShidWxrVGVtcGxhdGVTZXRzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlcy5zZXQoYnVsa1RlbXBsYXRlU2V0cywgb3B0aW9uc0ZvclRlbXBsYXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eShidWxrVGVtcGxhdGVVbnNldHMpKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGJ1bGtUZW1wbGF0ZVVuc2V0cywgZnVuY3Rpb24ocHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuX3RlbXBsYXRlcyAmJiB0aGF0Ll90ZW1wbGF0ZXMuaGFzKHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fdGVtcGxhdGVzLnVuc2V0KHByb3BOYW1lLCBvcHRpb25zRm9yVGVtcGxhdGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHkoYnVsa1NlbGZTZXRzKSkge1xuICAgICAgICAgICAgICAgIEJhc2VNb2RlbC5wcm90b3R5cGUuc2V0LmNhbGwodGhpcywgYnVsa1NlbGZTZXRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zLlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRva2Vucz1mYWxzZV0gLSBXaGVuIGB0cnVlYCwgcmV0dXJucyB0aGVcbiAgICAgICAgICogdGVtcGxhdGUgc3RyaW5nIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IHJhdGhlciB0aGFuIGl0cyBjdXJyZW50IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3Rva2VucycpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50b2tlbnMgPSB0aGlzLl9yZXRyaWV2ZVRva2Vuc0J5RGVmYXVsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUb2tlblV0aWxzLnF1b3RlQXNUb2tlblN0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgIEJhc2VNb2RlbC5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywga2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IEJhc2VNb2RlbC5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PSBudWxsICYmIG9wdGlvbnMucmV0YWluVW5tYXRjaGVkVG9rZW5zICYmIHRoaXMuX3RlbXBsYXRlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gVG9rZW5VdGlscy5yZXBsYWNlVG9rZW5zKHRoaXMuX3RlbXBsYXRlcy5nZXQoa2V5KSwgdGhpcy5fdG9rZW5SZWdpc3RyeSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5OYW1lc3BhY2U6IHRoaXMuX3Rva2VuTmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlcjogdGhpcy5fdG9rZW5Fc2NhcGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dOb0VzY2FwZTogdGhpcy5fYWxsb3dOb0VzY2FwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBkaWN0aW9uYXJ5IG9mIGFsbCBwcm9wZXJ0aWVzIGZvciB0aGlzIG1vZGVsXG4gICAgICAgICAqIHdpdGggdGhlIHNwZWNpZmllZCBwcmVmaXguIFRoZSBwcmVmaXggaXMgcmVtb3ZlZCBpbiB0aGUgcmV0dXJuZWQgY29weS5cbiAgICAgICAgICpcbiAgICAgICAgICogUHJvcGVydGllcyB0aGF0IGFyZSBjb21wdXRlZCBmcm9tIHRlbXBsYXRlcyBhcmUgcmV0dXJuZWRcbiAgICAgICAgICogYXMgYW4gYXBwcm9wcmlhdGUgYG12Yy50b2tlblNhZmUoLi4uKWAgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBleGFtcGxlLCBpZiB0aGlzIG1vZGVsIGhhcyBgeyd2YWx1ZSc6ICdmb28nLCAndHBfdmFsdWUnOiAnYmFyJ31gLFxuICAgICAgICAgKiBhbmQgdGhlIHByZWZpeCBmb3IgZXh0cmFjdGlvbiBpcyBgJ3RwXydgLCB0aGUgcmV0dXJuZWQgZGljdGlvbmFyeVxuICAgICAgICAgKiBpcyBgeyd2YWx1ZSc6ICdiYXInfWAuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggLSBUaGUgcHJlZml4LlxuICAgICAgICAgKi9cbiAgICAgICAgZXh0cmFjdFdpdGhQcmVmaXg6IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgZXh0cmFjdGVkUHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgXy5lYWNoKF8ua2V5cyh0aGlzLmF0dHJpYnV0ZXMpLCBmdW5jdGlvbihwcm9wTmFtZU9uVGhpcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZU9uVGhpcy5pbmRleE9mKHByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BOYW1lT25UaGlzLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgcHJvcGVydHkncyB0ZW1wbGF0ZSBvciBsaXRlcmFsIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVZhbHVlID0gdGhhdC5nZXQocHJvcE5hbWVPblRoaXMsIHt0b2tlbnM6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gbXZjLnRva2VuU2FmZSh0ZW1wbGF0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9IHRoYXQuZ2V0KHByb3BOYW1lT25UaGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RlZFByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGV4dHJhY3RlZFByb3BlcnRpZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBjb3B5IG9mIGFsbCBwcm9wZXJ0aWVzIGZvciB0aGlzIG1vZGVsLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucy5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50b2tlbnM9ZmFsc2VdIC0gV2hlbiBgdHJ1ZWAsIHJldHVybnMgdGhlXG4gICAgICAgICAqIHRlbXBsYXRlIHN0cmluZyBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSByYXRoZXIgdGhhbiBpdHMgY3VycmVudCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgndG9rZW5zJykpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRva2VucyA9IHRoaXMuX3JldHJpZXZlVG9rZW5zQnlEZWZhdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICAgICAgLy8gRmlsbCBpbiBxdW90ZWQgbGl0ZXJhbHNcbiAgICAgICAgICAgICAgICBfLmVhY2godGhpcy5hdHRyaWJ1dGVzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdGhhdC5nZXQoa2V5LCB7dG9rZW5zOiB0cnVlfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gRmlsbCBpbiByZWFsIHRlbXBsYXRlc1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF8uZXh0ZW5kKHJlc3VsdCwgdGhpcy5fdGVtcGxhdGVzLnRvSlNPTigpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmFzZU1vZGVsLnByb3RvdHlwZS50b0pTT04uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlcy5kZWVwT2ZmKCk7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5fYmluZGluZ3MsIHRoaXMuX2Rpc3Bvc2VCaW5kaW5nTGlzdGVuZXJzKTtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdzID0ge307XG4gICAgICAgICAgICB0aGlzLmRlZXBPZmYoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGlzcG9zZUJpbmRpbmdMaXN0ZW5lcnM6IGZ1bmN0aW9uKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGJpbmRpbmcuX2xpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuX2xpc3RlbmVycyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKlxuICAgICAqIENyZWF0ZXMgYW4gZW1wdHkgcmVwb3J0IG1vZGVsIGZvciB1c2UgYnkgbG93LWxldmVsIGNvcmUgVUkgdmlld3MuXG4gICAgICpcbiAgICAgKiBDb3JlIFVJIHZpZXdzIGV4cGVjdCB0aGF0IHRlbXBsYXRlZCBwcm9wZXJ0aWVzIGNhbiBhbHdheXMgYmVcbiAgICAgKiBhY2Nlc3NlZCBhbmQgdGhhdCB0aGV5IHJldGFpbiB1bm1hdGNoZWQgdG9rZW5zLiBJdCBpcyBhbHNvIGFzc3VtZWRcbiAgICAgKiB0aGF0IHRlbXBsYXRlZCBwcm9wZXJ0aWVzIGNhbiBiZSBzZXQgd2l0aG91dCBzcGVjaWZ5aW5nIGB7dG9rZW5zOiB0cnVlfWBcbiAgICAgKiBleHBsaWNpdGx5LlxuICAgICAqXG4gICAgICogUGFja2FnZS1wcml2YXRlLlxuICAgICAqL1xuICAgIFRva2VuQXdhcmVNb2RlbC5fY3JlYXRlUmVwb3J0TW9kZWwgPSBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuQXdhcmVNb2RlbChhdHRyaWJ1dGVzIHx8IHt9LCBfLmV4dGVuZCh7XG4gICAgICAgICAgICBhcHBseVRva2Vuc0J5RGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICAgIHJldGFpblVubWF0Y2hlZFRva2VuczogdHJ1ZVxuICAgICAgICB9LCBvcHRpb25zKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBUb2tlbkF3YXJlTW9kZWw7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9hbG9tb3Rhbi9Eb2N1bWVudHMvdm1zaGFyZS9zY3JhdGNocGFkL3JlYWN0L29uc3BsdW5rL25vZGVfbW9kdWxlcy9Ac3BsdW5rL3NwbHVuay13ZWItY29yZS9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvc3BsdW5ranMvbXZjL3Rva2VuYXdhcmVtb2RlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///133\n");

/***/ }),

/***/ 134:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n    var _ = __webpack_require__(121);\n    var Backbone = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"backbone\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    var console = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"util/console\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    var DomTrackerMixin = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"mixins/domtracker\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    var mvc = __webpack_require__(125);\n\n    /**\n     * @constructor\n     * @memberOf splunkjs.mvc\n     * @name BaseManager\n     * @private\n     * @description The **BaseManager** base class is used for search managers.\n     * This class is not designed to be instantiated directly.\n     * @extends splunkjs.mvc.Backbone.Model\n     * @mixes domtracker\n     */\n    var BaseManager = Backbone.Model.extend(/** @lends splunkjs.mvc.BaseManager.prototype */{\n        constructor: function(attributes, options) {\n            attributes = attributes || {};\n            options = options || {};\n\n            // Get or generate a name\n            var id = options.id || attributes.id;\n\n            if (id === undefined) {\n                id = options.name || attributes.name;\n                if (id !== undefined) {\n                    console.log(\"Use of 'name' to specify the ID of a Splunk model is deprecated.\");\n                }\n            }\n\n            if (id === undefined) {\n                id = _.uniqueId('manager_');\n            }\n\n            // Store it on the instance/options\n            this.id = this.name = options.name = options.id = id;\n\n            // Register it on the global registry\n            this.registry = options.registry || options._tokenRegistry || mvc.Components;\n\n            var returned = Backbone.Model.prototype.constructor.apply(this, arguments);\n            this.registry.registerInstance(this.id, this, { replace: options.replace });\n\n            return returned;\n        },\n\n        _start: function() {},\n\n        dispose: function() {\n            this.stopListeningDOM();\n            this.stopListening();\n\n            if (this.registry.getInstance(this.id) === this) {\n                this.registry.revokeInstance(this.id);\n            }\n        },\n\n        getType: function() {\n            return this.settings.get('type') || 'primary';\n        }\n    });\n\n    _.extend(BaseManager.prototype, DomTrackerMixin);\n\n    return BaseManager;\n}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n/**\n * Search progress event.\n *\n * @event\n * @name splunkjs.mvc.BaseManager#search\n * @property {Boolean} search:cancelled - Fired when the search is cancelled. Changing the properties of the search starts a new one, which may cancel an old search.\n * @property {Boolean} search:done - Fired when the search has finished. Note that this event is never fired for a real-time search.\n * @property {Boolean} search:error - Fired when an error occurs, such as when the user does not provide a search query, the user does not provide a valid name of a saved search, or when a network failure occurs.\n * @property {Boolean} search:failed - Fired when the search job fails.\n * @property {Boolean} search:progress - Fired to indicate search progress.\n * @property {Boolean} search:start - Fired when the search is successfully started.\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2Fsb21vdGFuL0RvY3VtZW50cy92bXNoYXJlL3NjcmF0Y2hwYWQvcmVhY3Qvb25zcGx1bmsvbm9kZV9tb2R1bGVzL0BzcGx1bmsvc3BsdW5rLXdlYi1jb3JlL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zcGx1bmtqcy9tdmMvYmFzZW1hbmFnZXIuanM/YThiZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxxRUFBTztBQUNQLFlBQVksbUJBQU8sQ0FBQyxHQUFZO0FBQ2hDLG1CQUFtQixtQkFBTyxDQUFDLG9JQUFVO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLHdJQUFjO0FBQ3hDLDBCQUEwQixtQkFBTyxDQUFDLDZJQUFtQjtBQUNyRCxjQUFjLG1CQUFPLENBQUMsR0FBTzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELDJCQUEyQjs7QUFFdEY7QUFDQSxTQUFTOztBQUVULDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLENBQUM7QUFBQSxvR0FBQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QiIsImZpbGUiOiIxMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgdmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG4gICAgdmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcbiAgICB2YXIgY29uc29sZSA9IHJlcXVpcmUoJ3V0aWwvY29uc29sZScpO1xuICAgIHZhciBEb21UcmFja2VyTWl4aW4gPSByZXF1aXJlKCdtaXhpbnMvZG9tdHJhY2tlcicpO1xuICAgIHZhciBtdmMgPSByZXF1aXJlKCcuL212YycpO1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlck9mIHNwbHVua2pzLm12Y1xuICAgICAqIEBuYW1lIEJhc2VNYW5hZ2VyXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlICoqQmFzZU1hbmFnZXIqKiBiYXNlIGNsYXNzIGlzIHVzZWQgZm9yIHNlYXJjaCBtYW5hZ2Vycy5cbiAgICAgKiBUaGlzIGNsYXNzIGlzIG5vdCBkZXNpZ25lZCB0byBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gICAgICogQGV4dGVuZHMgc3BsdW5ranMubXZjLkJhY2tib25lLk1vZGVsXG4gICAgICogQG1peGVzIGRvbXRyYWNrZXJcbiAgICAgKi9cbiAgICB2YXIgQmFzZU1hbmFnZXIgPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoLyoqIEBsZW5kcyBzcGx1bmtqcy5tdmMuQmFzZU1hbmFnZXIucHJvdG90eXBlICove1xuICAgICAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgLy8gR2V0IG9yIGdlbmVyYXRlIGEgbmFtZVxuICAgICAgICAgICAgdmFyIGlkID0gb3B0aW9ucy5pZCB8fCBhdHRyaWJ1dGVzLmlkO1xuXG4gICAgICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlkID0gb3B0aW9ucy5uYW1lIHx8IGF0dHJpYnV0ZXMubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVzZSBvZiAnbmFtZScgdG8gc3BlY2lmeSB0aGUgSUQgb2YgYSBTcGx1bmsgbW9kZWwgaXMgZGVwcmVjYXRlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlkID0gXy51bmlxdWVJZCgnbWFuYWdlcl8nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RvcmUgaXQgb24gdGhlIGluc3RhbmNlL29wdGlvbnNcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWUgPSBvcHRpb25zLmlkID0gaWQ7XG5cbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIGl0IG9uIHRoZSBnbG9iYWwgcmVnaXN0cnlcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cnkgPSBvcHRpb25zLnJlZ2lzdHJ5IHx8IG9wdGlvbnMuX3Rva2VuUmVnaXN0cnkgfHwgbXZjLkNvbXBvbmVudHM7XG5cbiAgICAgICAgICAgIHZhciByZXR1cm5lZCA9IEJhY2tib25lLk1vZGVsLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RyeS5yZWdpc3Rlckluc3RhbmNlKHRoaXMuaWQsIHRoaXMsIHsgcmVwbGFjZTogb3B0aW9ucy5yZXBsYWNlIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3N0YXJ0OiBmdW5jdGlvbigpIHt9LFxuXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nRE9NKCk7XG4gICAgICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucmVnaXN0cnkuZ2V0SW5zdGFuY2UodGhpcy5pZCkgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdHJ5LnJldm9rZUluc3RhbmNlKHRoaXMuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuZ2V0KCd0eXBlJykgfHwgJ3ByaW1hcnknO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBfLmV4dGVuZChCYXNlTWFuYWdlci5wcm90b3R5cGUsIERvbVRyYWNrZXJNaXhpbik7XG5cbiAgICByZXR1cm4gQmFzZU1hbmFnZXI7XG59KTtcbi8qKlxuICogU2VhcmNoIHByb2dyZXNzIGV2ZW50LlxuICpcbiAqIEBldmVudFxuICogQG5hbWUgc3BsdW5ranMubXZjLkJhc2VNYW5hZ2VyI3NlYXJjaFxuICogQHByb3BlcnR5IHtCb29sZWFufSBzZWFyY2g6Y2FuY2VsbGVkIC0gRmlyZWQgd2hlbiB0aGUgc2VhcmNoIGlzIGNhbmNlbGxlZC4gQ2hhbmdpbmcgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNlYXJjaCBzdGFydHMgYSBuZXcgb25lLCB3aGljaCBtYXkgY2FuY2VsIGFuIG9sZCBzZWFyY2guXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNlYXJjaDpkb25lIC0gRmlyZWQgd2hlbiB0aGUgc2VhcmNoIGhhcyBmaW5pc2hlZC4gTm90ZSB0aGF0IHRoaXMgZXZlbnQgaXMgbmV2ZXIgZmlyZWQgZm9yIGEgcmVhbC10aW1lIHNlYXJjaC5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2VhcmNoOmVycm9yIC0gRmlyZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMsIHN1Y2ggYXMgd2hlbiB0aGUgdXNlciBkb2VzIG5vdCBwcm92aWRlIGEgc2VhcmNoIHF1ZXJ5LCB0aGUgdXNlciBkb2VzIG5vdCBwcm92aWRlIGEgdmFsaWQgbmFtZSBvZiBhIHNhdmVkIHNlYXJjaCwgb3Igd2hlbiBhIG5ldHdvcmsgZmFpbHVyZSBvY2N1cnMuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNlYXJjaDpmYWlsZWQgLSBGaXJlZCB3aGVuIHRoZSBzZWFyY2ggam9iIGZhaWxzLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzZWFyY2g6cHJvZ3Jlc3MgLSBGaXJlZCB0byBpbmRpY2F0ZSBzZWFyY2ggcHJvZ3Jlc3MuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNlYXJjaDpzdGFydCAtIEZpcmVkIHdoZW4gdGhlIHNlYXJjaCBpcyBzdWNjZXNzZnVsbHkgc3RhcnRlZC5cbiAqL1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2Fsb21vdGFuL0RvY3VtZW50cy92bXNoYXJlL3NjcmF0Y2hwYWQvcmVhY3Qvb25zcGx1bmsvbm9kZV9tb2R1bGVzL0BzcGx1bmsvc3BsdW5rLXdlYi1jb3JlL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zcGx1bmtqcy9tdmMvYmFzZW1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///134\n");

/***/ }),

/***/ 135:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n    var _ = __webpack_require__(121);\n    var mvc = __webpack_require__(125);\n    var console = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"util/console\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    var Backbone = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"backbone\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    var Settings = __webpack_require__(136);\n    var viewloggingmixin = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"mixins/viewlogging\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    var ComponentBindingMixin = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"dashboard/mixins/ComponentBindingMixin\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n    /**\n     * @constructor\n     * @memberOf splunkjs.mvc\n     * @name BaseSplunkView\n     * @private\n     * @description The **BaseSplunkView** base view class is used for Splunk\n     * views. This class is not designed to be subclassed. Extend\n     * {@link splunkjs.mvc.SimpleSplunkView} instead.\n     * @extends splunkjs.mvc.Backbone.View\n     * @mixes viewlogging\n     *\n     * @param {Object} options\n     * @param {String} options.id - The unique ID for this control.\n     * @param {String} options.el - Pre-existing &lt;div&gt; tag in which to render\n     * this view.\n     * @param {Object} options.settings -  A **Settings** model instance to\n     * use.\n     * @param {Object} options.settingsOptions -  Initial options for this\n     * view's **Settings** model.\n     * @param {Object} options.* - Initial attributes for this view's\n     * **Settings** model. See the subclass documentation for details.\n     * @param {Object} settingsOptions - The initial options for this view's\n     * **Settings** model.\n     */\n    var BaseSplunkView = Backbone.View.extend(/** @lends splunkjs.mvc.BaseSplunkView.prototype */{\n        _numConfigureCalls: 0,\n\n        /**\n         * @protected\n         * Names of options that will be excluded from this component's\n         * settings model if passed to the constructor.\n         */\n        omitFromSettings: [],\n        _uniqueIdPrefix: 'view_',\n\n        constructor: function(options, settingsOptions) {\n            options = options || {};\n            settingsOptions = settingsOptions || {};\n\n            options.settingsOptions = _.extend(\n                options.settingsOptions || {},\n                settingsOptions);\n\n            // Internal property to track object lifetime.\n            // With this flag we want to prevent invoking methods / code\n            // on already removed instance.\n            this._removed = false;\n\n            // Get an ID or generate one\n            var id = options.id;\n            if (id === undefined && options.name) {\n                id = options.name;\n                console.warn(\"Use of 'name' to specify the ID of a Splunk model is deprecated.\");\n            }\n\n            if (id === undefined) {\n                id = _.uniqueId(this._uniqueIdPrefix || 'view_');\n            }\n\n            this.name = this.id = options.name = options.id = id;\n\n            this.options = _.extend({}, this.options, options);\n            this.registry = this.options.settingsOptions.registry\n                || this.options.settingsOptions._tokenRegistry\n                || mvc.Components;\n\n            // Delegate to Backbone.View's constructor.\n            // NOTE: This will call initialize() as a side effect.\n            var returned = Backbone.View.prototype.constructor.apply(this, arguments);\n            if (this._numConfigureCalls == 0) {\n                // initialize() should have called configure() but did not.\n                // In this case automatically call configure().\n                this.configure();\n            }\n\n            this.registry.registerInstance(this.id, this, { replace: settingsOptions.replace });\n            return returned;\n        },\n\n        /**\n         * @protected\n         * Initializes this view's settings model based on the contents of\n         * `this.options`.\n         */\n        configure: function() {\n            this._numConfigureCalls++;\n            if (this._numConfigureCalls > 1) {\n                throw new Error('BaseSplunkView.configure() called multiple times.');\n            }\n\n            // We may have received a Settings model instance to use instead\n            // of creating our own. If so, we just use it and return immediately.\n            var settings = this.options.settings;\n            if (settings && (settings instanceof Settings)) {\n                this.settings = settings;\n                return this;\n            }\n\n            // Reinterpret remaining view options as settings attributes.\n            var localOmitFromSettings = (this.omitFromSettings || []).concat(\n                ['model', 'collection', 'el', 'attributes',\n                 'className', 'tagName', 'events', 'settingsOptions']);\n\n            var settingsAttributes = _.omit(this.options, localOmitFromSettings);\n            var settingsOptions = this.options.settingsOptions;\n\n            // Now, we create our default settings model.\n            this.settings = new Settings(settingsAttributes, _.extend({}, settingsOptions, {\n                _tokenRegistry: this.registry\n            }));\n\n            return this;\n        },\n\n        // JIRA: Just invoke configure() from constructor() instead of\n        //       relying on subclasses to do it. (Don't forget to update\n        //       the doc comment above.) (DVPL-2436)\n        /**\n         * Initializes this view.\n         *\n         * Subclasses are expected to override this method.\n         *\n         * All implementations must call {@link splunkjs.mvc.configure | configure}, usually at the beginning\n         * of this method.\n         */\n        initialize: function() {\n            Backbone.View.prototype.initialize.apply(this, arguments);\n        },\n\n        remove: function() {\n            this._removed = true;\n\n            this.settings.dispose();\n\n            // Call our super class\n            Backbone.View.prototype.remove.apply(this, arguments);\n\n            // Remove it from the registry\n            if (this.registry.getInstance(this.id) === this) {\n                this.registry.revokeInstance(this.id);\n            }\n\n            return this;\n        },\n\n        dispose: function() {\n            this.remove();\n        },\n\n        setElement: function() {\n            // We're doing this in setElement for a few reasons:\n            // 1. It means that subclasses won't have to worry about\n            // calling our initialize class.\n            // 2. It is actually the most robust way to do this, because\n            // it means we will catch both construction of new views, as\n            // well as later calls to setElement\n\n            // Call our super class\n            Backbone.View.prototype.setElement.apply(this, arguments);\n\n            // Now that we have our new $el, we can call addClass on it\n            this.$el.addClass(\"splunk-view\");\n            if (this.className) {\n                this.$el.addClass(this.className);\n            }\n\n            if (!this.$el.attr('id')) {\n                this.$el.attr('id', this.id);\n            }\n\n            // This is for QA engineers to easily grab DOM element by \"data-view\" attribute.\n            // This approach has been used in core views/Base.js for a long long time.\n            if (this.moduleId) {\n                this.$el.attr('data-view', this.moduleId);\n            }\n\n            return this;\n        }\n    });\n\n    _.extend(BaseSplunkView.prototype, ComponentBindingMixin, viewloggingmixin);\n\n    return BaseSplunkView;\n}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n/**\n * Click event.\n *\n * @event\n * @name splunkjs.mvc.TableView#click\n * @property {Boolean} click:row - Fired when a row is clicked.\n * @property {Boolean} click:chart - Fired when a cell is clicked.\n */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2Fsb21vdGFuL0RvY3VtZW50cy92bXNoYXJlL3NjcmF0Y2hwYWQvcmVhY3Qvb25zcGx1bmsvbm9kZV9tb2R1bGVzL0BzcGx1bmsvc3BsdW5rLXdlYi1jb3JlL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zcGx1bmtqcy9tdmMvYmFzZXNwbHVua3ZpZXcuanM/NjUwOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxxRUFBTztBQUNQLFlBQVksbUJBQU8sQ0FBQyxHQUFZO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxHQUFPO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLHdJQUFjO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLG9JQUFVO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLEdBQVk7QUFDdkMsMkJBQTJCLG1CQUFPLENBQUMsOElBQW9CO0FBQ3ZELGdDQUFnQyxtQkFBTyxDQUFDLGtLQUF3Qzs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9DQUFvQztBQUM1QztBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTywrQkFBK0IsT0FBTztBQUM1RDtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJELG1DQUFtQztBQUM5RjtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBLGFBQWE7O0FBRWI7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUNBQXlDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLENBQUM7QUFBQSxvR0FBQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCIiwiZmlsZSI6IjEzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuICAgIHZhciBtdmMgPSByZXF1aXJlKCcuL212YycpO1xuICAgIHZhciBjb25zb2xlID0gcmVxdWlyZSgndXRpbC9jb25zb2xlJyk7XG4gICAgdmFyIEJhY2tib25lID0gcmVxdWlyZShcImJhY2tib25lXCIpO1xuICAgIHZhciBTZXR0aW5ncyA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xuICAgIHZhciB2aWV3bG9nZ2luZ21peGluID0gcmVxdWlyZSgnbWl4aW5zL3ZpZXdsb2dnaW5nJyk7XG4gICAgdmFyIENvbXBvbmVudEJpbmRpbmdNaXhpbiA9IHJlcXVpcmUoJ2Rhc2hib2FyZC9taXhpbnMvQ29tcG9uZW50QmluZGluZ01peGluJyk7XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyT2Ygc3BsdW5ranMubXZjXG4gICAgICogQG5hbWUgQmFzZVNwbHVua1ZpZXdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgKipCYXNlU3BsdW5rVmlldyoqIGJhc2UgdmlldyBjbGFzcyBpcyB1c2VkIGZvciBTcGx1bmtcbiAgICAgKiB2aWV3cy4gVGhpcyBjbGFzcyBpcyBub3QgZGVzaWduZWQgdG8gYmUgc3ViY2xhc3NlZC4gRXh0ZW5kXG4gICAgICoge0BsaW5rIHNwbHVua2pzLm12Yy5TaW1wbGVTcGx1bmtWaWV3fSBpbnN0ZWFkLlxuICAgICAqIEBleHRlbmRzIHNwbHVua2pzLm12Yy5CYWNrYm9uZS5WaWV3XG4gICAgICogQG1peGVzIHZpZXdsb2dnaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmlkIC0gVGhlIHVuaXF1ZSBJRCBmb3IgdGhpcyBjb250cm9sLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmVsIC0gUHJlLWV4aXN0aW5nICZsdDtkaXYmZ3Q7IHRhZyBpbiB3aGljaCB0byByZW5kZXJcbiAgICAgKiB0aGlzIHZpZXcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuc2V0dGluZ3MgLSAgQSAqKlNldHRpbmdzKiogbW9kZWwgaW5zdGFuY2UgdG9cbiAgICAgKiB1c2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuc2V0dGluZ3NPcHRpb25zIC0gIEluaXRpYWwgb3B0aW9ucyBmb3IgdGhpc1xuICAgICAqIHZpZXcncyAqKlNldHRpbmdzKiogbW9kZWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuKiAtIEluaXRpYWwgYXR0cmlidXRlcyBmb3IgdGhpcyB2aWV3J3NcbiAgICAgKiAqKlNldHRpbmdzKiogbW9kZWwuIFNlZSB0aGUgc3ViY2xhc3MgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NPcHRpb25zIC0gVGhlIGluaXRpYWwgb3B0aW9ucyBmb3IgdGhpcyB2aWV3J3NcbiAgICAgKiAqKlNldHRpbmdzKiogbW9kZWwuXG4gICAgICovXG4gICAgdmFyIEJhc2VTcGx1bmtWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoLyoqIEBsZW5kcyBzcGx1bmtqcy5tdmMuQmFzZVNwbHVua1ZpZXcucHJvdG90eXBlICove1xuICAgICAgICBfbnVtQ29uZmlndXJlQ2FsbHM6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogTmFtZXMgb2Ygb3B0aW9ucyB0aGF0IHdpbGwgYmUgZXhjbHVkZWQgZnJvbSB0aGlzIGNvbXBvbmVudCdzXG4gICAgICAgICAqIHNldHRpbmdzIG1vZGVsIGlmIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBvbWl0RnJvbVNldHRpbmdzOiBbXSxcbiAgICAgICAgX3VuaXF1ZUlkUHJlZml4OiAndmlld18nLFxuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbihvcHRpb25zLCBzZXR0aW5nc09wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgc2V0dGluZ3NPcHRpb25zID0gc2V0dGluZ3NPcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICBvcHRpb25zLnNldHRpbmdzT3B0aW9ucyA9IF8uZXh0ZW5kKFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2V0dGluZ3NPcHRpb25zIHx8IHt9LFxuICAgICAgICAgICAgICAgIHNldHRpbmdzT3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIEludGVybmFsIHByb3BlcnR5IHRvIHRyYWNrIG9iamVjdCBsaWZldGltZS5cbiAgICAgICAgICAgIC8vIFdpdGggdGhpcyBmbGFnIHdlIHdhbnQgdG8gcHJldmVudCBpbnZva2luZyBtZXRob2RzIC8gY29kZVxuICAgICAgICAgICAgLy8gb24gYWxyZWFkeSByZW1vdmVkIGluc3RhbmNlLlxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBHZXQgYW4gSUQgb3IgZ2VuZXJhdGUgb25lXG4gICAgICAgICAgICB2YXIgaWQgPSBvcHRpb25zLmlkO1xuICAgICAgICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgaWQgPSBvcHRpb25zLm5hbWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVXNlIG9mICduYW1lJyB0byBzcGVjaWZ5IHRoZSBJRCBvZiBhIFNwbHVuayBtb2RlbCBpcyBkZXByZWNhdGVkLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZCA9IF8udW5pcXVlSWQodGhpcy5fdW5pcXVlSWRQcmVmaXggfHwgJ3ZpZXdfJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMuaWQgPSBvcHRpb25zLm5hbWUgPSBvcHRpb25zLmlkID0gaWQ7XG5cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RyeSA9IHRoaXMub3B0aW9ucy5zZXR0aW5nc09wdGlvbnMucmVnaXN0cnlcbiAgICAgICAgICAgICAgICB8fCB0aGlzLm9wdGlvbnMuc2V0dGluZ3NPcHRpb25zLl90b2tlblJlZ2lzdHJ5XG4gICAgICAgICAgICAgICAgfHwgbXZjLkNvbXBvbmVudHM7XG5cbiAgICAgICAgICAgIC8vIERlbGVnYXRlIHRvIEJhY2tib25lLlZpZXcncyBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgd2lsbCBjYWxsIGluaXRpYWxpemUoKSBhcyBhIHNpZGUgZWZmZWN0LlxuICAgICAgICAgICAgdmFyIHJldHVybmVkID0gQmFja2JvbmUuVmlldy5wcm90b3R5cGUuY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9udW1Db25maWd1cmVDYWxscyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSgpIHNob3VsZCBoYXZlIGNhbGxlZCBjb25maWd1cmUoKSBidXQgZGlkIG5vdC5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UgYXV0b21hdGljYWxseSBjYWxsIGNvbmZpZ3VyZSgpLlxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVnaXN0cnkucmVnaXN0ZXJJbnN0YW5jZSh0aGlzLmlkLCB0aGlzLCB7IHJlcGxhY2U6IHNldHRpbmdzT3B0aW9ucy5yZXBsYWNlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybmVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoaXMgdmlldydzIHNldHRpbmdzIG1vZGVsIGJhc2VkIG9uIHRoZSBjb250ZW50cyBvZlxuICAgICAgICAgKiBgdGhpcy5vcHRpb25zYC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9udW1Db25maWd1cmVDYWxscysrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX251bUNvbmZpZ3VyZUNhbGxzID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmFzZVNwbHVua1ZpZXcuY29uZmlndXJlKCkgY2FsbGVkIG11bHRpcGxlIHRpbWVzLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSBtYXkgaGF2ZSByZWNlaXZlZCBhIFNldHRpbmdzIG1vZGVsIGluc3RhbmNlIHRvIHVzZSBpbnN0ZWFkXG4gICAgICAgICAgICAvLyBvZiBjcmVhdGluZyBvdXIgb3duLiBJZiBzbywgd2UganVzdCB1c2UgaXQgYW5kIHJldHVybiBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMub3B0aW9ucy5zZXR0aW5ncztcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncyAmJiAoc2V0dGluZ3MgaW5zdGFuY2VvZiBTZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlaW50ZXJwcmV0IHJlbWFpbmluZyB2aWV3IG9wdGlvbnMgYXMgc2V0dGluZ3MgYXR0cmlidXRlcy5cbiAgICAgICAgICAgIHZhciBsb2NhbE9taXRGcm9tU2V0dGluZ3MgPSAodGhpcy5vbWl0RnJvbVNldHRpbmdzIHx8IFtdKS5jb25jYXQoXG4gICAgICAgICAgICAgICAgWydtb2RlbCcsICdjb2xsZWN0aW9uJywgJ2VsJywgJ2F0dHJpYnV0ZXMnLFxuICAgICAgICAgICAgICAgICAnY2xhc3NOYW1lJywgJ3RhZ05hbWUnLCAnZXZlbnRzJywgJ3NldHRpbmdzT3B0aW9ucyddKTtcblxuICAgICAgICAgICAgdmFyIHNldHRpbmdzQXR0cmlidXRlcyA9IF8ub21pdCh0aGlzLm9wdGlvbnMsIGxvY2FsT21pdEZyb21TZXR0aW5ncyk7XG4gICAgICAgICAgICB2YXIgc2V0dGluZ3NPcHRpb25zID0gdGhpcy5vcHRpb25zLnNldHRpbmdzT3B0aW9ucztcblxuICAgICAgICAgICAgLy8gTm93LCB3ZSBjcmVhdGUgb3VyIGRlZmF1bHQgc2V0dGluZ3MgbW9kZWwuXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gbmV3IFNldHRpbmdzKHNldHRpbmdzQXR0cmlidXRlcywgXy5leHRlbmQoe30sIHNldHRpbmdzT3B0aW9ucywge1xuICAgICAgICAgICAgICAgIF90b2tlblJlZ2lzdHJ5OiB0aGlzLnJlZ2lzdHJ5XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEpJUkE6IEp1c3QgaW52b2tlIGNvbmZpZ3VyZSgpIGZyb20gY29uc3RydWN0b3IoKSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vICAgICAgIHJlbHlpbmcgb24gc3ViY2xhc3NlcyB0byBkbyBpdC4gKERvbid0IGZvcmdldCB0byB1cGRhdGVcbiAgICAgICAgLy8gICAgICAgdGhlIGRvYyBjb21tZW50IGFib3ZlLikgKERWUEwtMjQzNilcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoaXMgdmlldy5cbiAgICAgICAgICpcbiAgICAgICAgICogU3ViY2xhc3NlcyBhcmUgZXhwZWN0ZWQgdG8gb3ZlcnJpZGUgdGhpcyBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFsbCBpbXBsZW1lbnRhdGlvbnMgbXVzdCBjYWxsIHtAbGluayBzcGx1bmtqcy5tdmMuY29uZmlndXJlIHwgY29uZmlndXJlfSwgdXN1YWxseSBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAqIG9mIHRoaXMgbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmRpc3Bvc2UoKTtcblxuICAgICAgICAgICAgLy8gQ2FsbCBvdXIgc3VwZXIgY2xhc3NcbiAgICAgICAgICAgIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgcmVnaXN0cnlcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZ2lzdHJ5LmdldEluc3RhbmNlKHRoaXMuaWQpID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RyeS5yZXZva2VJbnN0YW5jZSh0aGlzLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gV2UncmUgZG9pbmcgdGhpcyBpbiBzZXRFbGVtZW50IGZvciBhIGZldyByZWFzb25zOlxuICAgICAgICAgICAgLy8gMS4gSXQgbWVhbnMgdGhhdCBzdWJjbGFzc2VzIHdvbid0IGhhdmUgdG8gd29ycnkgYWJvdXRcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgb3VyIGluaXRpYWxpemUgY2xhc3MuXG4gICAgICAgICAgICAvLyAyLiBJdCBpcyBhY3R1YWxseSB0aGUgbW9zdCByb2J1c3Qgd2F5IHRvIGRvIHRoaXMsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIGl0IG1lYW5zIHdlIHdpbGwgY2F0Y2ggYm90aCBjb25zdHJ1Y3Rpb24gb2YgbmV3IHZpZXdzLCBhc1xuICAgICAgICAgICAgLy8gd2VsbCBhcyBsYXRlciBjYWxscyB0byBzZXRFbGVtZW50XG5cbiAgICAgICAgICAgIC8vIENhbGwgb3VyIHN1cGVyIGNsYXNzXG4gICAgICAgICAgICBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5zZXRFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgb3VyIG5ldyAkZWwsIHdlIGNhbiBjYWxsIGFkZENsYXNzIG9uIGl0XG4gICAgICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcyhcInNwbHVuay12aWV3XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWwuYWRkQ2xhc3ModGhpcy5jbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuJGVsLmF0dHIoJ2lkJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbC5hdHRyKCdpZCcsIHRoaXMuaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGZvciBRQSBlbmdpbmVlcnMgdG8gZWFzaWx5IGdyYWIgRE9NIGVsZW1lbnQgYnkgXCJkYXRhLXZpZXdcIiBhdHRyaWJ1dGUuXG4gICAgICAgICAgICAvLyBUaGlzIGFwcHJvYWNoIGhhcyBiZWVuIHVzZWQgaW4gY29yZSB2aWV3cy9CYXNlLmpzIGZvciBhIGxvbmcgbG9uZyB0aW1lLlxuICAgICAgICAgICAgaWYgKHRoaXMubW9kdWxlSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbC5hdHRyKCdkYXRhLXZpZXcnLCB0aGlzLm1vZHVsZUlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIF8uZXh0ZW5kKEJhc2VTcGx1bmtWaWV3LnByb3RvdHlwZSwgQ29tcG9uZW50QmluZGluZ01peGluLCB2aWV3bG9nZ2luZ21peGluKTtcblxuICAgIHJldHVybiBCYXNlU3BsdW5rVmlldztcbn0pO1xuLyoqXG4gKiBDbGljayBldmVudC5cbiAqXG4gKiBAZXZlbnRcbiAqIEBuYW1lIHNwbHVua2pzLm12Yy5UYWJsZVZpZXcjY2xpY2tcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY2xpY2s6cm93IC0gRmlyZWQgd2hlbiBhIHJvdyBpcyBjbGlja2VkLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBjbGljazpjaGFydCAtIEZpcmVkIHdoZW4gYSBjZWxsIGlzIGNsaWNrZWQuXG4gKi9cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9hbG9tb3Rhbi9Eb2N1bWVudHMvdm1zaGFyZS9zY3JhdGNocGFkL3JlYWN0L29uc3BsdW5rL25vZGVfbW9kdWxlcy9Ac3BsdW5rL3NwbHVuay13ZWItY29yZS9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvc3BsdW5ranMvbXZjL2Jhc2VzcGx1bmt2aWV3LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///135\n");

/***/ }),

/***/ 136:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n    var TokenAwareModel = __webpack_require__(133);\n\n    /**\n     * @constructor\n     * @memberOf splunkjs.mvc\n     * @name Settings\n     * @description The **Settings** base input class contains the Settings model\n     * for SplunkJS components.\n     * @extends splunkjs.mvc.TokenAwareModel\n    */\n    var Settings = TokenAwareModel.extend(/** @lends splunkjs.mvc.Settings.prototype */{\n        sync: function() { return false; }\n    });\n    \n    return Settings;\n}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2Fsb21vdGFuL0RvY3VtZW50cy92bXNoYXJlL3NjcmF0Y2hwYWQvcmVhY3Qvb25zcGx1bmsvbm9kZV9tb2R1bGVzL0BzcGx1bmsvc3BsdW5rLXdlYi1jb3JlL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zcGx1bmtqcy9tdmMvc2V0dGluZ3MuanM/MTRmZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxxRUFBTztBQUNQLDBCQUEwQixtQkFBTyxDQUFDLEdBQW1COztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QyxLQUFLOztBQUVMO0FBQ0EsQ0FBQztBQUFBLG9HQUFDIiwiZmlsZSI6IjEzNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcbiAgICB2YXIgVG9rZW5Bd2FyZU1vZGVsID0gcmVxdWlyZSgnLi90b2tlbmF3YXJlbW9kZWwnKTtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJPZiBzcGx1bmtqcy5tdmNcbiAgICAgKiBAbmFtZSBTZXR0aW5nc1xuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgKipTZXR0aW5ncyoqIGJhc2UgaW5wdXQgY2xhc3MgY29udGFpbnMgdGhlIFNldHRpbmdzIG1vZGVsXG4gICAgICogZm9yIFNwbHVua0pTIGNvbXBvbmVudHMuXG4gICAgICogQGV4dGVuZHMgc3BsdW5ranMubXZjLlRva2VuQXdhcmVNb2RlbFxuICAgICovXG4gICAgdmFyIFNldHRpbmdzID0gVG9rZW5Bd2FyZU1vZGVsLmV4dGVuZCgvKiogQGxlbmRzIHNwbHVua2pzLm12Yy5TZXR0aW5ncy5wcm90b3R5cGUgKi97XG4gICAgICAgIHN5bmM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gU2V0dGluZ3M7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9hbG9tb3Rhbi9Eb2N1bWVudHMvdm1zaGFyZS9zY3JhdGNocGFkL3JlYWN0L29uc3BsdW5rL25vZGVfbW9kdWxlcy9Ac3BsdW5rL3NwbHVuay13ZWItY29yZS9zZWFyY2hfbXJzcGFya2xlL2V4cG9zZWQvanMvc3BsdW5ranMvbXZjL3NldHRpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///136\n");

/***/ }),

/***/ 137:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n    var _ = __webpack_require__(121);\n    var TokenAwareModel = __webpack_require__(133);\n    var TokenSafeString = __webpack_require__(126);\n    var splunkUtils = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"splunk.util\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n    \n    // Extends TokenAwareModel with an additional 'qualified'\n    // keyword option on the set() and get() methods.\n    var SearchSettingsModel = TokenAwareModel.extend(/** @lends splunkjs.mvc.SearchSettingsModel.prototype */{\n        set: function(key, val, options) {\n            var attrs;\n            if(key == null) {\n                return this;\n            }\n            if(typeof key === 'object') {\n                attrs = key;\n                options = val;\n            } else {\n                (attrs = {})[key] = val;\n            }\n\n            if(options && options.qualified && attrs.search) {\n                if(attrs.search instanceof TokenSafeString) {\n                    attrs.search = new TokenSafeString(splunkUtils.stripLeadingSearchCommand(attrs.search.value));\n                } else {\n                    attrs.search = splunkUtils.stripLeadingSearchCommand(attrs.search);\n                }\n            }\n            return TokenAwareModel.prototype.set.call(this, attrs, options);\n        },\n        get: function(attribute, options) {\n            var result = TokenAwareModel.prototype.get.apply(this, arguments);\n            \n            // We only want to add the leading search if:\n            // 1. the get is for 'search'\n            // 2. they explicitly asked for it to be qualified\n            // 3. there is an actual search string (i.e. not an empty string)\n            if(attribute === 'search' && options && options.qualified && result) {\n                result = splunkUtils.addLeadingSearchCommand(result);\n            }\n            \n            return result;\n        },\n        // Retained for internal backward compatibility concerns.\n        resolve: function(options) {\n            return this.get(\"search\", options);\n        }\n    });\n\n    /*\n     * Subset of attribute names on the SearchSettingsModel that will be passed\n     * through to the underlying search job that is created.\n     * \n     * This list is manually collected from the combination of:\n     *  * POST search/jobs\n     *  * POST saved/searches/<name>/dispatch\n     * You can find the various properties in the REST API reference documentation.\n     */\n    SearchSettingsModel.ALLOWED_ATTRIBUTES = [\n        \"adhoc_search_level\",\n        \"app\",\n        \"auto_cancel\",\n        \"auto_finalize_ec\",\n        \"auto_pause\",\n        \"buckets\",\n        \"earliest_time\",\n        \"enable_lookups\",\n        \"exec_mode\",\n        \"force_bundle_replication\",\n        \"indexedRealtime\",\n        \"indexedRealtimeOffset\",\n        \"latest_time\",\n        \"label\",\n        \"lookups\",\n        \"max_count\",\n        \"max_time\",\n        \"namespace\",\n        \"now\",\n        \"owner\",\n        \"preview\",\n        \"reduce_freq\",\n        \"reload_macros\",\n        \"remote_server_list\",\n        \"required_field_list\",\n        \"rf\",\n        \"rt_backfill\",\n        \"rt_blocking\",\n        \"rt_indexfilter\",\n        \"rt_maxblocksecs\",\n        \"rt_queue_size\",\n        \"search\",\n        \"search_listener\",\n        \"search_mode\",\n        \"spawn_process\",\n        \"status_buckets\",\n        \"sync_bundle_replication\",\n        \"time_format\",\n        \"timeout\",\n        \"ttl\",\n        \"sample_ratio\",\n        \"provenance\"\n    ];\n    \n    return {\n        SearchSettingsModel: SearchSettingsModel,\n        // Deprecated\n        SearchJob: SearchSettingsModel,\n        // Deprecated\n        SearchQuery: SearchSettingsModel\n    };\n}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2Fsb21vdGFuL0RvY3VtZW50cy92bXNoYXJlL3NjcmF0Y2hwYWQvcmVhY3Qvb25zcGx1bmsvbm9kZV9tb2R1bGVzL0BzcGx1bmsvc3BsdW5rLXdlYi1jb3JlL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zcGx1bmtqcy9tdmMvc2VhcmNobW9kZWwuanM/ZTcwZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxxRUFBTztBQUNQLFlBQVksbUJBQU8sQ0FBQyxHQUFZO0FBQ2hDLDBCQUEwQixtQkFBTyxDQUFDLEdBQW1CO0FBQ3JELDBCQUEwQixtQkFBTyxDQUFDLEdBQW1CO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLHVJQUFhOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQSxvR0FBQyIsImZpbGUiOiIxMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgdmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbiAgICB2YXIgVG9rZW5Bd2FyZU1vZGVsID0gcmVxdWlyZSgnLi90b2tlbmF3YXJlbW9kZWwnKTtcbiAgICB2YXIgVG9rZW5TYWZlU3RyaW5nID0gcmVxdWlyZShcIi4vdG9rZW5zYWZlc3RyaW5nXCIpO1xuICAgIHZhciBzcGx1bmtVdGlscyA9IHJlcXVpcmUoJ3NwbHVuay51dGlsJyk7XG4gICAgXG4gICAgLy8gRXh0ZW5kcyBUb2tlbkF3YXJlTW9kZWwgd2l0aCBhbiBhZGRpdGlvbmFsICdxdWFsaWZpZWQnXG4gICAgLy8ga2V5d29yZCBvcHRpb24gb24gdGhlIHNldCgpIGFuZCBnZXQoKSBtZXRob2RzLlxuICAgIHZhciBTZWFyY2hTZXR0aW5nc01vZGVsID0gVG9rZW5Bd2FyZU1vZGVsLmV4dGVuZCgvKiogQGxlbmRzIHNwbHVua2pzLm12Yy5TZWFyY2hTZXR0aW5nc01vZGVsLnByb3RvdHlwZSAqL3tcbiAgICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGF0dHJzO1xuICAgICAgICAgICAgaWYoa2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMgPSBrZXk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHZhbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKGF0dHJzID0ge30pW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5xdWFsaWZpZWQgJiYgYXR0cnMuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgaWYoYXR0cnMuc2VhcmNoIGluc3RhbmNlb2YgVG9rZW5TYWZlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnNlYXJjaCA9IG5ldyBUb2tlblNhZmVTdHJpbmcoc3BsdW5rVXRpbHMuc3RyaXBMZWFkaW5nU2VhcmNoQ29tbWFuZChhdHRycy5zZWFyY2gudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5zZWFyY2ggPSBzcGx1bmtVdGlscy5zdHJpcExlYWRpbmdTZWFyY2hDb21tYW5kKGF0dHJzLnNlYXJjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFRva2VuQXdhcmVNb2RlbC5wcm90b3R5cGUuc2V0LmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFRva2VuQXdhcmVNb2RlbC5wcm90b3R5cGUuZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byBhZGQgdGhlIGxlYWRpbmcgc2VhcmNoIGlmOlxuICAgICAgICAgICAgLy8gMS4gdGhlIGdldCBpcyBmb3IgJ3NlYXJjaCdcbiAgICAgICAgICAgIC8vIDIuIHRoZXkgZXhwbGljaXRseSBhc2tlZCBmb3IgaXQgdG8gYmUgcXVhbGlmaWVkXG4gICAgICAgICAgICAvLyAzLiB0aGVyZSBpcyBhbiBhY3R1YWwgc2VhcmNoIHN0cmluZyAoaS5lLiBub3QgYW4gZW1wdHkgc3RyaW5nKVxuICAgICAgICAgICAgaWYoYXR0cmlidXRlID09PSAnc2VhcmNoJyAmJiBvcHRpb25zICYmIG9wdGlvbnMucXVhbGlmaWVkICYmIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNwbHVua1V0aWxzLmFkZExlYWRpbmdTZWFyY2hDb21tYW5kKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJldGFpbmVkIGZvciBpbnRlcm5hbCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGNvbmNlcm5zLlxuICAgICAgICByZXNvbHZlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJzZWFyY2hcIiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qXG4gICAgICogU3Vic2V0IG9mIGF0dHJpYnV0ZSBuYW1lcyBvbiB0aGUgU2VhcmNoU2V0dGluZ3NNb2RlbCB0aGF0IHdpbGwgYmUgcGFzc2VkXG4gICAgICogdGhyb3VnaCB0byB0aGUgdW5kZXJseWluZyBzZWFyY2ggam9iIHRoYXQgaXMgY3JlYXRlZC5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGxpc3QgaXMgbWFudWFsbHkgY29sbGVjdGVkIGZyb20gdGhlIGNvbWJpbmF0aW9uIG9mOlxuICAgICAqICAqIFBPU1Qgc2VhcmNoL2pvYnNcbiAgICAgKiAgKiBQT1NUIHNhdmVkL3NlYXJjaGVzLzxuYW1lPi9kaXNwYXRjaFxuICAgICAqIFlvdSBjYW4gZmluZCB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIGluIHRoZSBSRVNUIEFQSSByZWZlcmVuY2UgZG9jdW1lbnRhdGlvbi5cbiAgICAgKi9cbiAgICBTZWFyY2hTZXR0aW5nc01vZGVsLkFMTE9XRURfQVRUUklCVVRFUyA9IFtcbiAgICAgICAgXCJhZGhvY19zZWFyY2hfbGV2ZWxcIixcbiAgICAgICAgXCJhcHBcIixcbiAgICAgICAgXCJhdXRvX2NhbmNlbFwiLFxuICAgICAgICBcImF1dG9fZmluYWxpemVfZWNcIixcbiAgICAgICAgXCJhdXRvX3BhdXNlXCIsXG4gICAgICAgIFwiYnVja2V0c1wiLFxuICAgICAgICBcImVhcmxpZXN0X3RpbWVcIixcbiAgICAgICAgXCJlbmFibGVfbG9va3Vwc1wiLFxuICAgICAgICBcImV4ZWNfbW9kZVwiLFxuICAgICAgICBcImZvcmNlX2J1bmRsZV9yZXBsaWNhdGlvblwiLFxuICAgICAgICBcImluZGV4ZWRSZWFsdGltZVwiLFxuICAgICAgICBcImluZGV4ZWRSZWFsdGltZU9mZnNldFwiLFxuICAgICAgICBcImxhdGVzdF90aW1lXCIsXG4gICAgICAgIFwibGFiZWxcIixcbiAgICAgICAgXCJsb29rdXBzXCIsXG4gICAgICAgIFwibWF4X2NvdW50XCIsXG4gICAgICAgIFwibWF4X3RpbWVcIixcbiAgICAgICAgXCJuYW1lc3BhY2VcIixcbiAgICAgICAgXCJub3dcIixcbiAgICAgICAgXCJvd25lclwiLFxuICAgICAgICBcInByZXZpZXdcIixcbiAgICAgICAgXCJyZWR1Y2VfZnJlcVwiLFxuICAgICAgICBcInJlbG9hZF9tYWNyb3NcIixcbiAgICAgICAgXCJyZW1vdGVfc2VydmVyX2xpc3RcIixcbiAgICAgICAgXCJyZXF1aXJlZF9maWVsZF9saXN0XCIsXG4gICAgICAgIFwicmZcIixcbiAgICAgICAgXCJydF9iYWNrZmlsbFwiLFxuICAgICAgICBcInJ0X2Jsb2NraW5nXCIsXG4gICAgICAgIFwicnRfaW5kZXhmaWx0ZXJcIixcbiAgICAgICAgXCJydF9tYXhibG9ja3NlY3NcIixcbiAgICAgICAgXCJydF9xdWV1ZV9zaXplXCIsXG4gICAgICAgIFwic2VhcmNoXCIsXG4gICAgICAgIFwic2VhcmNoX2xpc3RlbmVyXCIsXG4gICAgICAgIFwic2VhcmNoX21vZGVcIixcbiAgICAgICAgXCJzcGF3bl9wcm9jZXNzXCIsXG4gICAgICAgIFwic3RhdHVzX2J1Y2tldHNcIixcbiAgICAgICAgXCJzeW5jX2J1bmRsZV9yZXBsaWNhdGlvblwiLFxuICAgICAgICBcInRpbWVfZm9ybWF0XCIsXG4gICAgICAgIFwidGltZW91dFwiLFxuICAgICAgICBcInR0bFwiLFxuICAgICAgICBcInNhbXBsZV9yYXRpb1wiLFxuICAgICAgICBcInByb3ZlbmFuY2VcIlxuICAgIF07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgU2VhcmNoU2V0dGluZ3NNb2RlbDogU2VhcmNoU2V0dGluZ3NNb2RlbCxcbiAgICAgICAgLy8gRGVwcmVjYXRlZFxuICAgICAgICBTZWFyY2hKb2I6IFNlYXJjaFNldHRpbmdzTW9kZWwsXG4gICAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgICAgU2VhcmNoUXVlcnk6IFNlYXJjaFNldHRpbmdzTW9kZWxcbiAgICB9O1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2Fsb21vdGFuL0RvY3VtZW50cy92bXNoYXJlL3NjcmF0Y2hwYWQvcmVhY3Qvb25zcGx1bmsvbm9kZV9tb2R1bGVzL0BzcGx1bmsvc3BsdW5rLXdlYi1jb3JlL3NlYXJjaF9tcnNwYXJrbGUvZXhwb3NlZC9qcy9zcGx1bmtqcy9tdmMvc2VhcmNobW9kZWwuanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///137\n");

/***/ })

});